# AGENTS (Zusammengefuehrte Markdown-Dokumentation)

Generiert am: 2026-03-01T08:13:48Z


---

## Datei: .ralf-host/artifacts/host-plan.md

# Host Bootstrap Plan (Conservative)

- Workspace: `/root/RALF/.ralf-host`
- Runtime dir: `/root/RALF/.ralf-host/runtime`
- Tool readiness: `partial`

## Required Tools
- bash: present (/usr/bin/bash)
- curl: present (/usr/bin/curl)
- git: present (/usr/bin/git)
- tar: present (/usr/bin/tar)
- sha256sum: present (/usr/bin/sha256sum)

## Optional Tools (for future phases)
- minisign: missing
- lxc: missing
- pct: present (/usr/sbin/pct)
- tofu: missing
- terragrunt: missing
- ansible: missing

## Next Actions (not executed by host adapter)
- Install missing optional tools as needed for local execution (e.g. tofu, terragrunt, ansible, minisign)
- Populate `/root/RALF/.ralf-host/runtime/secrets` with environment/secrets files before local runner usage
- Add/choose a host-mode runner workflow


---

## Datei: .ralf-host/artifacts/host-runner.md

# Host Runner (Guarded)

Generated by the host bootstrap adapter.

Files:

- `/root/RALF/.ralf-host/config/host-runner.env` - environment defaults for a future local runner
- `/root/RALF/.ralf-host/bin/ralf-host-runner` - helper wrapper for guarded local runner execution

Current behavior:

- `--check`: validates local prerequisites and prints derived paths
- `--dry-run`: prints a preview of the runner invocation
- `--status` / `--artifacts`: summarize generated host artifacts
- `--run`: guarded execution of `bootstrap/runner.sh` (requires explicit env gates)

Next step to make this real:

1. Install optional tools (`tofu`, `terragrunt`, `ansible`)
2. Populate `/root/RALF/.ralf-host/runtime/secrets`
3. Enable targeted stack runs only after validating a safe host-mode workflow (e.g. `RUN_STACKS=0` first, then selected stacks)


---

## Datei: AGENTS.md

# AGENTS.md (Repo-Guide für zukünftige Sessions)

Diese Datei gilt für das gesamte Repository.

## 1) Arbeitsmodus (wichtig)
- Lies **diese Datei zu Beginn jeder Session komplett**.
- Arbeite in kleinen, nachvollziehbaren Änderungen.
- Halte Entscheidungen kurz schriftlich fest (Was wurde geändert? Warum?).
- Bewahre die vorhandene Betriebslogik: **deterministisch, konservativ, nachvollziehbar**.

## 2) Projektüberblick
- `stacks/` enthält die auszuführenden Stacks:
  - Terraform/OpenTofu-Stacks (z. B. `030-minio-lxc`, `100-bootstrap-lxc`)
  - Ansible-Stack (`031-minio-config/playbook.yml`)
- `bootstrap/start.sh` ist der Host-seitige Seed für Proxmox (CT erstellen/starten, Toolchain, Repo, Secrets, Runner).
- `bootstrap/runner.sh` orchestriert die Stack-Ausführung im CT (`tofu plan/apply`, `ansible-playbook` bzw. Syntax-Check).
- `inventory/hosts.ini` wird von Ansible-Stacks genutzt.
- `docs/` enthält die normativen Leitplanken (Charta, Zielbild, Betriebsverfassung).

## 3) Architektur- und Betriebsprinzipien
- **LXC-first**, keine Docker-Einführung.
- Netzwerk basiert auf `10.10.0.0/16`.
- Sicherheit/Robustheit vor "cleveren" Kurzlösungen.
- Keine stillen Breaking Changes in Bootstrap- oder Runner-Logik.
- Bestehende Umgebungsvariablen und Defaults respektieren (Start-/Runner-Skripte sind darauf ausgelegt).

## 4) Konventionen im Code
### Shell (`bootstrap/*.sh`)
- Shebang + `set -euo pipefail` beibehalten.
- Keine unnötigen Abhängigkeiten einführen.
- Idempotenz bewahren (wiederholtes Ausführen darf nicht unerwartet zerstören).
- Bestehende Toggle-Flags (`NO_*`, `AUTO_APPLY`, `START_AT`, `ONLY_STACKS`) nicht brechen.

### Terraform/OpenTofu (`*.tf`)
- Vorhandenen Stil beibehalten (klare Blöcke, sinnvolle Defaults, sensitive Variablen markieren).
- Provider-/Version-Pinning nicht ohne Grund aufweichen.
- Änderungen an IPs/VMIDs/CTIDs bewusst und dokumentiert durchführen.

### Ansible (`stacks/*/playbook.yml`)
- Idempotente Tasks bevorzugen.
- `become`, Dateirechte und Besitzverhältnisse explizit halten.
- Bei secret-relevanten Dateien restriktive Rechte (`0600`) beibehalten.

### Dokumentation
- Kurz, klar, operativ nützlich.
- Deutsche Sprache ist in diesem Repo bevorzugt.

## 5) Validierung vor Abschluss
Führe – passend zur Änderung – so viel wie möglich aus:
- Shell-Syntax:
  - `bash -n bootstrap/start.sh bootstrap/runner.sh`
- Terraform/OpenTofu-Format (je Stack mit `.tf`):
  - `tofu fmt -check -recursive`
- Ansible-Syntax:
  - `ansible-playbook -i inventory/hosts.ini --syntax-check stacks/031-minio-config/playbook.yml`

Wenn Tools in der Umgebung fehlen: klar als Einschränkung dokumentieren.

## 6) Änderungsschwerpunkte (Risiko-Hotspots)
- `bootstrap/start.sh`: beeinflusst CT-Lebenszyklus, Toolchain und Secrets-Injektion.
- `bootstrap/runner.sh`: steuert Reihenfolge und Art der Stack-Ausführung.
- `stacks/030-minio-lxc/main.tf`: produktive MinIO-LXC-Provisionierung.
- `stacks/031-minio-config/playbook.yml`: MinIO-Service-Installation inkl. systemd/Env-Handling.

## 7) Nicht tun
- Keine Secrets im Klartext ins Repo schreiben.
- Keine ad-hoc Strukturänderungen ohne Dokumentation.
- Keine impliziten Annahmen über produktive Erreichbarkeit externer Dienste.
- Keine großflächigen Refactorings ohne klaren Mehrwert und Tests.

## 8) Erwartung an Commit-/PR-Qualität
- Kleine, thematisch fokussierte Commits.
- Commit-Message mit Zweck + Kontext.
- PR-Beschreibung mit:
  - Ausgangslage
  - Änderung
  - Risiken
  - Validierung


---

## Datei: README.md

# RALF

RALF ist ein Homelab-/Infra-Repository fuer den Aufbau und Betrieb einer orchestrierten Plattform auf Proxmox.

Der aktuelle Fokus ist ein reproduzierbarer Bootstrap mit fruehem Handover zu `Semaphore`:

- `MinIO` fuer S3-kompatiblen Remote-State
- `PostgreSQL` als gemeinsame Datenbank
- `Gitea` als internes Git-Repository
- `Semaphore` als Ausfuehrungs- und Orchestrierungsplattform

Danach werden weitere Dienste ueber Semaphore-Tasks ausgerollt (u. a. `Vaultwarden`, `n8n`, `Synapse`, `Mail`, `exo`).

## Festgelegte Basiswerte (2026-02-28)

- Primaere Domain: `otta.zone`
- Netzwerk: `10.10.0.0/16`
- Bootstrap-Netz (temporaer): `10.10.250.0/24`
- Bootstrap-Lifecycle: explizit `ephemeral`, nach Erfolg stoppen und manuell loeschen
- Foundation (Welle 1): `PostgreSQL`, `Gitea`, `Semaphore`, `Prometheus`, `Vaultwarden`
- Welle 2: `n8n`, `Exo`, `Ollama`, `Synapse+Element`
- Kanonische Variablen/Policy: `bootstrap/VARS.md`
- Kanonische Checks/Gates: `bootstrap/CHECKS.md`
- Beispiel-Answers fuer diesen Stand: `bootstrap/examples/answers.otta.zone.yml`

## Zielbild (Auszug)

- Infrastruktur mit `OpenTofu` + `Terragrunt`
- Konfiguration mit `Ansible`
- Secrets aktuell ueber `.env`-Dateien (spaeter Richtung `Vaultwarden`)
- Schrittweise Smokes/Healthchecks nach jedem Deployment-Schritt

## Wichtige Verzeichnisse

- `bootstrap/` - Bootstrap, Runner, Smokes, Runbooks
- `stacks/` - einzelne Infra-/Config-Stacks (LXC + Dienstkonfiguration)
- `inventory/` - Ansible-Inventar

## Einstieg

### Runner (lokal, aktueller Stand)

```bash
bash bootstrap/runner.sh --answers-file bootstrap/examples/answers.otta.zone.yml --outputs-dir ./outputs
```

Optional mit Gate + Apply:

```bash
ACK=DEPLOY bash bootstrap/runner.sh --apply --outputs-dir ./outputs
```

Hinweis: `--apply` fuehrt jetzt echte `pct create/start`-Provisionierung fuer Foundation + Welle 2 aus
(`postgres`, `gitea`, `semaphore`, `prometheus`, `vaultwarden`, `n8n`, `minio`, `exo_*`, `ollama_llm`, `matrix_element`).
Der Runner schreibt dabei u. a. `checkpoints.json`, `cleanup_manifest.json`, `handover_report.json`, `endpoints.md`.

### Seed + Runner (Stufe A -> B)

```bash
bash bootstrap/start.sh --answers-file bootstrap/examples/answers.otta.zone.yml --outputs-dir ./outputs
```

Mit Integritaetspruefung (SHA256) fuer den Runner:

```bash
RUNNER_SHA256="<sha256_von_bootstrap_runner.sh>" \
bash bootstrap/start.sh --runner-path bootstrap/runner.sh --verify-only
```

### Bootstrap One-Liner (Quick Start, unsicher)

```bash
curl -fsSL https://raw.githubusercontent.com/default82/RALF/main/bootstrap/start.sh | bash
```

Fuer interaktive TUI-Runs (empfohlen bei Erststart) funktioniert auch `| bash`, robuster ist aber:

```bash
bash -c "$(curl -fsSL https://raw.githubusercontent.com/default82/RALF/main/bootstrap/start.sh)"
```

### Parametrisierter One-Liner

```bash
PROVISIONER=host PROFILE=ops NETWORK_CIDR=10.10.0.0/16 BASE_DOMAIN=otta.zone TUI=1 \
bash -c "$(curl -fsSL https://raw.githubusercontent.com/default82/RALF/main/bootstrap/start.sh)"
```

Mit separatem Output-Verzeichnis (z. B. fuer Vergleiche zwischen Runs):

```bash
PROVISIONER=host YES=1 APPLY=1 OUTPUTS_DIR=/tmp/ralf-bootstrap-run1 \
bash -c "$(curl -fsSL https://raw.githubusercontent.com/default82/RALF/main/bootstrap/start.sh)"
```

Unterstuetzte ENV-Parameter (`bootstrap/start.sh` -> `ralf bootstrap`):

- `PROVISIONER=proxmox_pct|host|lxd` (autodetect: `pct` -> `proxmox_pct`, `lxc` -> `lxd`, sonst `host`)
- `PROFILE`
- `NETWORK_CIDR`
- `BASE_DOMAIN`
- `CT_HOSTNAME`
- `TUI=1|0`
- Default: `TUI=1`, wenn TTY vorhanden und `NON_INTERACTIVE!=1` (grafische TUI via `dialog`/`whiptail`, sonst Prompt-Fallback)
- `HOST_PVE_ENV` (Pfad zu Proxmox-API-Secrets auf dem Host)
- `SSH_PRIVKEY_FILE` / `SSH_PUBKEY_FILE` (Pfade fuer ralf SSH-Key)
- `NON_INTERACTIVE=1|0`
- `YES=1|0`
- `FORCE=1|0`
- `ANSWERS_FILE`
- `EXPORT_ANSWERS`
- `OUTPUTS_DIR`

Beispiel fuer Answers-Datei:

- `bootstrap/examples/answers.otta.zone.yml` (empfohlen fuer den aktuellen Zielstand)

Provisioner-Status aktuell:

- `proxmox_pct`: produktiv (delegiert an `bootstrap/adapters/proxmox_pct.sh`)
  - TUI zeigt Quellen/Pfade (Secrets, `pve.env`, SSH-Key), erlaubt Pfadwahl und SSH-Key-Generierung
- `host`: konservativer Minimal-Adapter (legt lokales Workspace-Layout an, keine destruktiven Host-Aenderungen)
  - erzeugt `.ralf-host/bin/ralf-host-runner` mit `--check`, `--dry-run`, `--status`, `--artifacts`, `--json`, `--quiet`, guarded `--run` (default non-apply)
- `lxd`: konservativer Minimal-Adapter (Artefakte + Gatekeeping, erstellt LXD-Instanz falls fehlend und stempelt `user.ralf.*` Metadaten)
  - schreibt zusaetzliche LXD-Artefakte in `OUTPUTS_DIR/lxd/` (Plan + target/applied Metadata)

Phase-1-Cleanroom-Test (MinIO -> PostgreSQL -> Gitea -> Semaphore):

```bash
bash bootstrap/cleanroom-phase1.sh
```

Ab Phase 1 (Semaphore-first Betrieb):

- Runbook: `bootstrap/RUNBOOK-SEMAPHORE.md`
- Template-Runner: `bootstrap/sem-run-template.sh`

Beispiele:

```bash
./bootstrap/sem-run-template.sh --list
./bootstrap/sem-run-template.sh "RALF Phase1 Smoke"
./bootstrap/sem-run-template.sh --json --no-wait "RALF Communication Apply"
```

## Dokumentation

- `bootstrap/README.md` - sichere Startmodi (`SHA256`, `minisign`) und Maintainer-Workflow
- `bootstrap/RUNBOOK.md` - Bootstrap/Transition (`MinIO -> PostgreSQL -> Gitea -> Semaphore`)
- `bootstrap/RUNBOOK-SEMAPHORE.md` - Betrieb ab Phase 1 (Semaphore-first)
- `bootstrap/ARCHITEKTUR.md`, `bootstrap/CHECKS.md`, `bootstrap/VARS.md`

## Hinweis

Das Repository ist auf einen konkreten Homelab-Kontext zugeschnitten (Netze, IP-Schema, Proxmox-Node, Domains). Fuer andere Umgebungen muessen Variablen/Secrets/Inventar angepasst werden.


---

## Datei: bootstrap/ARCHITEKTUR.md

# RALF Bootstrap Architektur

Stand: 2026-02-28 (Europe/Berlin)

## Leitplanken

- LXC-first, kein Docker.
- Jeder Schritt liefert `ok`, `warn` oder `blocker` inkl. kurzer Summary.
- Gitea ist kanonische Wahrheit (Single Source of Truth), GitHub nur Distribution.
- Bootstrap darf starten, aber nicht blind durchlaufen.
- Primaere Domain: `otta.zone` (kein internes `homelab.lan` noetig).

## Zielbild (One-Entry Bootstrap)

Ein Einstieg (One-liner) fuehrt reproduzierbar bis zum Zustand "RALF steht":

1. Preflight checks
2. Plan-Artefakte erzeugen
3. Kontrollierte Ausfuehrung (Default mit Bestaetigung)
4. Foundation deployen:
   - PostgreSQL
   - Gitea
   - Semaphore
   - Prometheus
   - Vaultwarden
5. Repo-Seed und Handover nach Gitea
6. Erweiterung deployen:
   - n8n
   - KI-Komponenten (Exo + LLM)
7. Proof-Deployment: MinIO via Semaphore (OpenTofu + Ansible)
8. Bootstrap-LXC als obsolete markieren, stoppen, Loeschkommando ausgeben

## Zwei-Stufen-Modell

### Stufe A: Seed (ultraklein)

- Konfiguration lesen (`env`, `answers.yml`, optional TUI)
- Preflight ausfuehren
- Runner-Bundle holen
- Integritaet pruefen (`sha256` oder `minisign`)
- Runner im Bootstrap-LXC starten

### Stufe B: Runner (im Bootstrap-LXC)

- Workspace + `outputs/` initialisieren
- Bootstrap-Repo initial von GitHub klonen
- Konfiguration mergen und finalisieren
- Plan erzeugen (IPs, CTIDs, Ressourcen)
- Gatekeeping erzwingen
- Foundation erstellen/konfigurieren/verifizieren
- Gitea/Semaphore initialisieren
- Canonical Remote auf Gitea umschalten

## Phasenmodell mit Checkpoints

- Checkpoint A: Probe/Preflight
- Checkpoint B: Plan/Gate
- Checkpoint C: Apply (Provisionierung)
- Checkpoint D: Configure/Verify/Handover

Alle Checkpoints schreiben nach `outputs/checkpoints.json`.

## Netzwerk- und ID-Konventionen

- Basisnetz: `10.10.0.0/16`
- Bootstrap-Netz (temporaer): `10.10.250.0/24`
- Funktionsgruppen:
  - `10` Hardware/Hosts
  - `20` Datenbanken
  - `30` Backup/Sicherheit
  - `40` Web/Admin
  - `50` Directory/Auth
  - `60` Medien
  - `70` Dokumente/Wissen
  - `80` Monitoring/Logging
  - `90` KI/Datenverarbeitung
  - `100` Automatisierung/Steuerung
  - `110` Kommunikation
  - `120` Spiele
  - `200` funktionale VM-Reserve
  - `0` Netzwerk (Router/Switches)

CTID/VMID-Ableitung:

- Formel: `CTID = <octet3><octet4_padded_3>`
- Beispiele:
  - `10.10.20.10 -> 20010`
  - `10.10.40.10 -> 40010`
  - `10.10.100.20 -> 100020`

## Bootstrap-LXC Lifecycle

Der Bootstrap-Container ist explizit temporaer:

- Name z. B. `ralf-bootstrap-<timestamp>` oder `tmp-ralf-bootstrap`
- Metadaten/Tags:
  - `ralf.role=bootstrap`
  - `ralf.lifecycle=ephemeral`
  - `ralf.delete_ok=true`
- Abschlussverhalten:
  - Container stoppen
  - Loeschkommando nur anzeigen (manuelles Delete)

Pflichtartefakt:

- `outputs/cleanup_manifest.json` mit CTIDs/IPs, Ephemeral-Markierung, Cleanup-Empfehlungen

## Secrets- und DB-Policy

- Waehrend Bootstrap: `secrets.json` nur transient im Runner-Workspace
- SSH-Keys aus `/root/ralf-secrets`
- Nach Vaultwarden-Start: Secrets uebertragen und `secrets.json` loeschen
- Keine Klartext-Secrets ins Repo

DB-Konvention:

- PostgreSQL bevorzugt, wenn Dienst es unterstuetzt
- Naming:
  - Datenbank: `<service>_db`
  - User: `<service>_user`
- Fallback: MariaDB mit gleicher Namenskonvention
- Passwoerter mindestens 32 Zeichen

## Distribution und Handover

- GitHub (`ralf/bootstrap`) fuer Launcher, Doku, Beispiele, Releases/Signaturen
- Gitea ist intern kanonisch
- Nach erfolgreichem Gitea-Bootstrap wird das Canonical Remote auf Gitea umgestellt


---

## Datei: bootstrap/CHECKS.md

# RALF Bootstrap Checks

Stand: 2026-02-28

## Gatekeeping Contract

Jeder Schritt liefert genau einen Status:

- `ok`: Ausfuehrung sicher fortsetzbar
- `warn`: Fortsetzung nur nach expliziter Bestaetigung
- `blocker`: keine Fortsetzung, Abbruch mit Summary

Ausgabe immer:

- kurzer menschlicher Status
- maschinenlesbare Artefakte in `outputs/`

## Ack-Policy

Default:

- Plan anzeigen
- kurze Bestaetigung einholen

Nicht-interaktive Freigabe:

- Flag: `--yes`
- Env: `ACK=DEPLOY` (Token konfigurierbar)

## Checkpoints

### Checkpoint A (Probe/Preflight)

Mindestpruefungen:

- Runner-Umgebung ist host-nah (`pct` verfuegbar)
- Proxmox-Node/Storage konfigurierbar
- Netz-Parameter valide (`10.10.0.0/16`, Gateway, DNS)
- Pflichtwerte vorhanden (`admin`, SSH-Key, Domain, Distribution/Integrity)

`blocker` Beispiele:

- `pct` fehlt
- ungueltiges CIDR/Gateway
- kritische Secrets/Schluessel nicht verfuegbar

`warn` Beispiele:

- Template fehlt, aber Auto-Download moeglich
- optionale Integritaetsinfo fehlt, fallback verfuegbar

### Checkpoint B (Plan/Gate)

Mindestpruefungen:

- IP-Allocation kollisionsfrei
- CTID-Ableitung eindeutig
- Ressourcen-Plan plausibel (Defaults + begruendete Erhoehungen)
- Stages/Naming valide (`ops`, `dev`, `lab`)

`blocker` Beispiele:

- IP-Kollision
- doppelte CTID
- unzulaessige Stage

`warn` Beispiele:

- RAM-Erhoehung gegenueber Default noetig
- nichtkritische Ports/Proxy-Prechecks unsicher

### Checkpoint C (Apply)

Mindestpruefungen:

- Foundation-LXCs per `pct` erstellt (`postgres`, `gitea`, `semaphore`, `prometheus`, `vaultwarden`)
- Welle-2/Proof-LXCs per `pct` erstellt (`n8n`, `minio`, `exo_*`, `ollama_llm`, `matrix_element`)
- Basis-Metadaten gesetzt (ephemeral/persistent)
- apply-report geschrieben

`blocker` Beispiele:

- `pct create`/`pct start` Fehler
- Storage/Template nicht nutzbar

`warn` Beispiele:

- Retry erfolgreich nach transientem Fehler

### Checkpoint D (Configure/Verify/Handover)

Mindestpruefungen:

- Foundation-Dienste erreichbar
- Repo-Seed in Gitea vorhanden
- Semaphore Projekt/Templates/Keys vorbereitet
- n8n + KI-Komponenten deployed (Welle 2)
- MinIO-Proof via Semaphore laeuft

`blocker` Beispiele:

- Gitea oder Semaphore nicht erreichbar
- Handover auf kanonisches Remote nicht abgeschlossen

`warn` Beispiele:

- Teil-Smoke erfolgreich, aber Zusatzkomponente degradiert

## Artefakt-Vertrag (Pflicht)

Mindestens diese Dateien muessen entstehen:

- `outputs/probe_report.json`
- `outputs/final_config.json`
- `outputs/checkpoints.json`
- `outputs/plan_summary.md`
- `outputs/password_summary.md` (maskiert)
- `outputs/handover_report.json`
- `outputs/endpoints.md`

Ergaenzend fuer Lifecycle:

- `outputs/cleanup_manifest.json`

## Exitcodes

- `0`: Gesamtstatus `ok`
- `1`: Gesamtstatus `warn`
- `2`: `blocker` oder technischer Fehler


---

## Datei: bootstrap/README.md

## Bootstrap Start Modes

Aktueller Implementierungsstand in diesem Repo:

- `bootstrap/start.sh`: Seed-Stufe (Preflight, optional SHA256/minisign, Runner-Start)
- `bootstrap/runner.sh`: Runner (Checkpoints A-D, Artefakt-Vertrag, Gatekeeping, Foundation-Welle-1 `pct`-Apply)
- Historische Hinweise unten koennen Teile referenzieren, die in diesem reduzierten Tree noch fehlen.

### 1) Quick Start (unsafe)

```bash
curl -fsSL https://raw.githubusercontent.com/default82/RALF/main/bootstrap/start.sh | bash
```

Interaktive TUI-Runs (empfohlen) können auch so gestartet werden:

```bash
bash -c "$(curl -fsSL https://raw.githubusercontent.com/default82/RALF/main/bootstrap/start.sh)"
```

### 2) Danger Zone (recommended): pinned commit + SHA256 verify

```bash
set -euo pipefail
ORG="default82"; REPO="RALF"; COMMIT="<COMMIT_SHA_40>"; EXPECTED_SHA256="<START_SH_SHA256>"
URL="https://raw.githubusercontent.com/${ORG}/${REPO}/${COMMIT}/bootstrap/start.sh"
tmp="$(mktemp -d)"; trap 'rm -rf "$tmp"' EXIT
curl -fsSL "$URL" -o "$tmp/start.sh"
echo "${EXPECTED_SHA256}  $tmp/start.sh" | sha256sum -c -
bash "$tmp/start.sh"
```

Maintainer hash generation:

```bash
sha256sum bootstrap/start.sh
git show <COMMIT_SHA>:bootstrap/start.sh | sha256sum
bash bootstrap/release/print-start-integrity.sh --commit <COMMIT_SHA>
```

### 3) Production-ish (best): GitHub Release + minisign verify

Release assets:

- `start.sh`
- `start.sh.minisig`

User flow:

```bash
set -euo pipefail
ORG="default82"; REPO="RALF"; VERSION="<VERSION_TAG>"; PUBKEY="<MINISIGN_PUBLIC_KEY_STRING>"
BASE="https://github.com/${ORG}/${REPO}/releases/download/${VERSION}"
tmp="$(mktemp -d)"; trap 'rm -rf "$tmp"' EXIT
curl -fsSL "${BASE}/start.sh" -o "$tmp/start.sh"
curl -fsSL "${BASE}/start.sh.minisig" -o "$tmp/start.sh.minisig"
minisign -Vm "$tmp/start.sh" -P "$PUBKEY"
bash "$tmp/start.sh"
```

Maintainer setup (once):

```bash
minisign -G -p minisign.pub -s minisign.key
```

Per release:

```bash
minisign -S -s minisign.key -m bootstrap/start.sh -x start.sh.minisig
```

Publish only the minisign public key.

### GitHub Release Automation (CI)

The repo now includes:

- `.github/workflows/bootstrap-start-release.yml`
- `.github/workflows/bootstrap-selfcheck.yml`
- `bootstrap/release/sign-start.sh`
- `bootstrap/release/print-start-integrity.sh`

Workflow behavior:

- Trigger on published GitHub releases (and `workflow_dispatch`)
- Build/sign release artifacts for `bootstrap/start.sh`
- Upload to the GitHub Release:
  - `start.sh`
  - `start.sh.minisig`
  - `start.sh.sha256`
  - `manifest.txt`

Additionally, `bootstrap-selfcheck.yml` validates:

- shell syntax for launcher/CLI/adapters/release helpers
- `ralf bootstrap` host/lxd CLI paths (including expected no-`lxc` blocker)
- TUI policy behavior (`TUI=1` + `NON_INTERACTIVE=1`)
- `ANSWERS_FILE` merge using `bootstrap/examples/answers.otta.zone.yml`
- launcher end-to-end path using local `file://` repo checkout
- launcher ref handling checks including local tag ref
- integrity helper output (`bootstrap/release/print-start-integrity.sh`)
- verify helper flow (`bootstrap/release/verify-start.sh`) with mocked `curl`/`minisign`
- launcher relative-path arg handling (`ANSWERS_FILE` / `EXPORT_ANSWERS` / `OUTPUTS_DIR`)
- launcher hint logging for `TUI=1` + `NON_INTERACTIVE=1`

Local equivalent:

```bash
bash bootstrap/selfcheck.sh
bash bootstrap/selfcheck.sh --quick
```

The CI workflow also runs `bootstrap/selfcheck.sh --quick` to reduce drift between local and CI checks.
The full local selfcheck additionally validates launcher logging (resolved commit) and relative-path argument handling.

Required repository secret:

- `MINISIGN_SECRET_KEY_B64` : base64-encoded minisign secret key file contents

Recommended public key location in repo:

- `bootstrap/release/minisign.pub` (copy from `bootstrap/release/minisign.pub.example` and replace the placeholder)
- publish the same key in release notes/docs for out-of-band verification

Example secret creation:

```bash
base64 -w0 minisign.key
```

Local verification helper (optional):

```bash
bash bootstrap/release/verify-start.sh --version v1.0.0 --pubkey "<MINISIGN_PUBLIC_KEY_STRING>" --verify-only
bash bootstrap/release/verify-start.sh --version v1.0.0 --pubkey-file bootstrap/release/minisign.pub --verify-only
```

## Bootstrap Engine Contract

`bootstrap/start.sh` is a thin launcher. It fetches the repo and delegates to:

```bash
./ralf bootstrap
```

Launcher fetch behavior:

- uses `git` when available (with branch/tag/commit fetch fallbacks)
- otherwise falls back to GitHub tarball download (`branch` / `tag` / `commit` URL patterns)
- logs the resolved git commit (or extracted tarball directory) for traceability
- logs an early note when `TUI=1` and `NON_INTERACTIVE=1` are both set (before CLI gating disables TUI)
- forwards TUI defaults (`TUI=1` on TTY, otherwise `0`) unless explicitly set

### TUI behavior

- Default: TUI is enabled when a TTY is present and `NON_INTERACTIVE!=1`
- Backend order: `dialog` -> `whiptail` -> prompt fallback
- `curl | bash` is supported (prompts read from `/dev/tty`)
- `NON_INTERACTIVE=1` disables TUI and requires all mandatory values via env/answers/profile
- TUI Quellen-Seite zeigt feste Pfade/Status (`ralf-secrets`, `pve.env`, SSH keys), erlaubt Pfadwahl/Import und SSH-Key-Generierung
- Password summary is shown masked by default; full reveal is explicit in TUI

The CLI always writes:

- `outputs/probe_report.json`
- `outputs/final_config.json`
- `outputs/checkpoints.json`
- `outputs/answers.yml`
- `outputs/plan_summary.md`
- `outputs/cli_status.json`

`cli_status.json` also includes:

- `adapter_report_file` (main adapter report path, if any)
- `adapter_report_exists` (`true|false`, useful for no-apply runs)
- `adapter_artifacts` (machine-readable artifact list with `exists=true|false`)
- `tui_requested` / `tui_effective` (requested vs final TUI state after policy/gating)

Example (`cli_status.json` excerpt):

```json
{
  "adapter_report_file": "/tmp/ralf-run/host_apply_report.json",
  "adapter_artifacts": [
    {
      "key": "host_runner_wrapper",
      "path": "/path/to/.ralf-host/bin/ralf-host-runner",
      "exists": true
    }
  ]
}
```

Optional:

- `OUTPUTS_DIR` / `--outputs-dir` to isolate outputs per run (useful for sequential comparisons)
- example answers file: `bootstrap/examples/answers.otta.zone.yml`
- launcher resolves relative `ANSWERS_FILE` / `EXPORT_ANSWERS` / `OUTPUTS_DIR` paths against the caller's current directory

Example:

```bash
OUTPUTS_DIR=/tmp/ralf-bootstrap-run1 ./ralf bootstrap --provisioner host --apply --yes
./bootstrap/start.sh --answers-file bootstrap/examples/answers.otta.zone.yml
```

Exit codes:

- `0` ok
- `1` warn
- `2` blocker/error

Bootstrap phases:

1. Probe
2. Config merge (CLI > profile > defaults)
3. Policy / Gatekeeping
4. Provisioner
5. Artifact generation
6. Optional apply trigger (explicit only)

Provisioner adapter status:

- `proxmox_pct`: delegates to `bootstrap/adapters/proxmox_pct.sh`
- `host`: delegates to `bootstrap/adapters/host.sh` (minimal local apply: workspace prepare, no destructive changes, generates `ralf-host-runner`)
- `lxd`: delegates to `bootstrap/adapters/lxd.sh` (minimal apply: validates `lxc`/LXD, create-if-missing, stamps `user.ralf.*` metadata)
  - validates requested `LXD_PROFILE` before create/apply
  - writes LXD adapter artifacts under `OUTPUTS_DIR/lxd/` (`lxd-plan.md`, target/applied metadata JSON)

### Host Adapter Wrapper (`ralf-host-runner`)

The `host` adapter generates a helper wrapper at `.ralf-host/bin/ralf-host-runner`.

Current modes:

- `--check` : validate prerequisites and print derived paths
- `--dry-run` : print a preview of the future runner invocation
- `--status` : summarize generated host bootstrap artifacts/readiness
- `--artifacts` : list generated host bootstrap artifacts
- `--run` : guarded execution of `bootstrap/runner.sh` (requires `HOST_RUNNER_ENABLE_EXEC=1`; `AUTO_APPLY=1` also requires `HOST_RUNNER_ALLOW_APPLY=1`; full-stack runs need `ONLY_STACKS`/`START_AT` or `HOST_RUNNER_ALLOW_ALL_STACKS=1`)
- `--json` : machine-readable output for `--status` / `--artifacts`
- `--quiet` : suppress contextual header lines (where applicable)

Examples:

```bash
.ralf-host/bin/ralf-host-runner --status
.ralf-host/bin/ralf-host-runner --status --json
.ralf-host/bin/ralf-host-runner --artifacts --json
HOST_RUNNER_ENABLE_EXEC=1 RUN_STACKS=0 .ralf-host/bin/ralf-host-runner --run
```

### LXD Adapter Artifacts

When `--provisioner lxd --apply` runs, the adapter writes:

- `lxd_apply_report.json` (main adapter report)
  - includes `profile_exists` and `metadata_diff`
- `lxd/lxd-plan.md` (conservative LXD action summary)
- `lxd/lxd-metadata-targets.json` (intended `user.ralf.*` values)
- `lxd/lxd-metadata-applied.json` (actual values after apply, if LXD apply succeeds)


---

## Datei: bootstrap/RUNBOOK-SEMAPHORE.md

# RALF Runbook ab Phase 1 (Semaphore-first)

Dieses Runbook gilt **nach erfolgreicher Phase 1** (`MinIO`, `PostgreSQL`, `Gitea`, `Semaphore`).

Ziel: weitere Deployments standardisiert ueber `Semaphore` ausfuehren und direkt mit Smokes pruefen.

## Voraussetzungen

- `bootstrap/smoke.sh phase1` erfolgreich
- Semaphore erreichbar: `https://10.10.40.10/`
- Templates wurden durch `041-semaphore-config` geseedet

## Grundregel

1. `Apply`-Template starten
2. passendes `Smoke`-Template starten
3. bei Fehler: Logs in Semaphore pruefen, Fix im Repo, Commit/Push, Template erneut starten

`bootstrap/start.sh` bleibt nur fuer Recovery / Break-Glass.

## Standard-Reihenfolge ab Phase 1

1. `RALF Vault Apply`
2. `RALF Vault Smoke`
3. `RALF Automation Apply`
4. `RALF Automation Smoke`
5. `RALF Communication Apply`
6. `RALF Communication Smoke`
7. `RALF AI Apply`
8. `RALF AI Smoke`

## Einzelservice-Runs (gezielt)

Verwenden bei Fehleranalyse oder kleineren Aenderungen:

- `RALF Vaultwarden Apply`
- `RALF N8N Apply`
- `RALF Synapse Apply`
- `RALF Mail Apply`
- `RALF Exo Apply`

Danach jeweils passenden Gruppen-Smoke starten:

- Vaultwarden -> `RALF Vault Smoke`
- N8N -> `RALF Automation Smoke`
- Synapse/Mail -> `RALF Communication Smoke`
- Exo -> `RALF AI Smoke`

## Empfohlene Deploy-Muster

### Muster A: normale Aenderung an einem Dienst

1. Code aendern
2. Commit + Push
3. passendes Einzelservice-`Apply`
4. passendes Gruppen-`Smoke`

### Muster B: Aenderung an gemeinsam genutzter Basis (z. B. `smoke.sh`, Seeder, Runner)

1. Code aendern
2. Commit + Push
3. `RALF Phase1 Config Apply` (aktualisiert Semaphore-Host-Werkzeuge/Repo)
4. relevante Smokes (`Phase1`, dann betroffene Gruppen)

## Fehlerbehandlung (Standard)

- `tofu`-Fehler: zuerst MinIO/State-Erreichbarkeit und Proxmox-API pruefen
- `ansible`-Fehler: betroffenen Stack direkt ueber Einzelservice-Template wiederholen
- `smoke`-Fehler: zuerst Dienststatus im Ziel-CT, dann Nginx/TLS, dann App-Port
- `Semaphore`-Fehler: `041-semaphore-config` erneut ausrollen

## Cleanroom-Checks pro Phase

Nach einer abgeschlossenen groesseren Phase (z. B. neue Dienstgruppe produktionsreif):

1. `bash bootstrap/cleanroom-phase1.sh`
2. in Semaphore:
   - `RALF Phase1 Smoke`
   - betroffene Gruppen-Smokes

## API-Hinweis (falls manuell automatisiert wird)

Aktuelle Semaphore-Version startet Template-Tasks ueber:

- `POST /api/project/<id>/tasks` mit Body `{"template_id": <id>}`

Nicht mehr verwenden:

- `POST /api/project/<id>/templates/<id>/tasks` (liefert `404`)


---

## Datei: bootstrap/RUNBOOK.md

# RALF Bootstrap Runbook (Transition zu Semaphore)

Ziel: frueh auf `MinIO` (Remote State) und danach auf `Semaphore` als Ausfuehrungsplattform wechseln.

## Reihenfolge (verbindlich)

1. `MinIO` deployen (`030`, `031`)
2. `PostgreSQL` deployen (`020`, `021`)
3. `Gitea` deployen (`034`, `035`)
4. `Semaphore` deployen und seeden (`040`, `041`)
5. Ab hier weitere Dienste bevorzugt ueber Semaphore-Templates deployen

## Warum diese Reihenfolge

- `MinIO` zuerst: Remote-State (S3-kompatibel) steht frueh bereit.
- `PostgreSQL` danach: gemeinsame Datenbank fuer Folge-Dienste.
- `Gitea` vor `Semaphore`: internes Repo als Quelle fuer Jobs.
- `Semaphore` danach: zentrale Ausfuehrung, Logs, Wiederholbarkeit, Smoke-Tests.

## Phase 1 lokal/hostseitig ausfuehren

Cleanroom-Test (holt `start.sh` indirekt ueber `phase1-core.sh` aus GitHub und testet nach jedem Schritt):

```bash
cd /root/RALF
bash bootstrap/cleanroom-phase1.sh
```

Manuell (gezielte Phasen):

```bash
cd /root/RALF
AUTO_APPLY=1 START_AT=000 ONLY_STACKS='030-minio-lxc 031-minio-config' bash bootstrap/start.sh
bash bootstrap/smoke.sh minio

AUTO_APPLY=1 START_AT=000 ONLY_STACKS='020-postgres-lxc 021-postgres-config' bash bootstrap/start.sh
bash bootstrap/smoke.sh postgres

AUTO_APPLY=1 START_AT=000 ONLY_STACKS='034-gitea-lxc 035-gitea-config' bash bootstrap/start.sh
bash bootstrap/smoke.sh gitea

AUTO_APPLY=1 START_AT=000 ONLY_STACKS='040-semaphore-lxc 041-semaphore-config' bash bootstrap/start.sh
bash bootstrap/smoke.sh semaphore
```

## Phase 1 Abschlusskriterien

- `bootstrap/smoke.sh phase1` erfolgreich
- Semaphore-Templates existieren (Seed in `041`)
- Mindestens diese Template-Smokes erfolgreich:
  - `RALF Phase1 Smoke`
  - `RALF Vault Smoke`
  - `RALF Communication Smoke`

## Semaphore-Templates ausfuehren (API)

Hinweis: Task-Start erfolgt ueber `POST /api/project/<id>/tasks` mit `{\"template_id\":...}`.
Der alte Pfad `POST /api/project/<id>/templates/<id>/tasks` liefert in der aktuellen Semaphore-Version `404`.

Beispiel (innerhalb des Semaphore-Containers `4010`):

```bash
/root/sem_run_named.sh 'RALF Phase1 Smoke'
/root/sem_run_named.sh 'RALF Vault Smoke'
/root/sem_run_named.sh 'RALF Communication Smoke'
```

## Betriebsmodus nach Phase 1

- Infrastruktur-/Config-Runs bevorzugt ueber Semaphore ausfuehren.
- `bootstrap/start.sh` bleibt als Recovery-/Break-Glass-Pfad erhalten.
- Nach abgeschlossener groesserer Phase immer ein Cleanroom-Test + relevante Smokes ausfuehren.


---

## Datei: bootstrap/STATUS.md

# Bootstrap Status

Stand: 2026-02-28

## Kurzfazit

Die Planungsbasis fuer den neuen RALF-Bootstrap ist jetzt als verbindliche
Dokumentations-Spezifikation im Repo abgelegt.

Aktueller Scope dieses Repos:

- Architektur- und Policy-Definitionen sind konkretisiert
- Variablenkatalog + Beispiel-Answers sind vorhanden
- Gatekeeping- und Artefakt-Vertrag sind dokumentiert
- Seed-Launcher ist implementiert (`bootstrap/start.sh`)
- Runner ist implementiert (`bootstrap/runner.sh`)
- Foundation + Welle 2 CT-Provisionierung kann per `pct` laufen (`--apply`)

Noch offen:

- externe Runner-Bundle-Distribution (Release-Assets + Signaturfluss) final anbinden
- Service-Konfiguration innerhalb der CTs (Ansible/OpenTofu-Stacks) nach Provisionierung
- automatische Handover-Logik auf Gitea + Semaphore-Seeding
- Welle 2 Deployment- und Verifikationskette (n8n, KI, Matrix/Element, MinIO-Proof via Semaphore)

## Abgedeckte Entscheidungen (2026-02-28)

- LXC-first
- `10.10.0.0/16` als dauerhaftes Netzschema
- `10.10.250.0/24` als temporaeres Bootstrap-Netz
- Foundation-Welle 1 inkl. fester IP-Reservierungen
- Welle 2 (n8n, Exo, Ollama, Matrix/Element) inkl. fester IPs
- Gatekeeping mit `ok/warn/blocker`, Default-Ack und `--yes`/`ACK=DEPLOY`
- Ephemeral-Bootstrap-Lifecycle mit manuellem Delete
- GitHub als Distribution, Gitea als kanonische Wahrheit

## Dokumente (kanonisch)

- `bootstrap/ARCHITEKTUR.md`
- `bootstrap/CHECKS.md`
- `bootstrap/VARS.md`
- `bootstrap/examples/answers.otta.zone.yml`

## Definition of Done (Phase 1)

Phase 1 gilt als erreicht, wenn mindestens:

- Gitea erreichbar und Repo-Seed vorhanden
- Semaphore erreichbar und Templates vorhanden
- n8n erreichbar
- PostgreSQL erreichbar (`ralf_db`, `ralf_user`)

Erst danach gilt "Foundation lebt" fuer die weitere Automation.


---

## Datei: bootstrap/VARS.md

# RALF Bootstrap Variablenkatalog

Stand: 2026-02-28

Ziel: Ein einzelnes `answers.yml` als Eingabe. Daraus leitet der Runner
`outputs/final_config.json` ab.

## Konventionen

- Source of truth waehrend des Runs: `answers.yml` + Runtime-Secrets
- Klartext-Secrets nie ins Repo
- Defaults sind konservativ und LXC-first

## Kanonisches Strukturbeispiel

```yaml
global:
  primary_domain: otta.zone
  timezone: Europe/Berlin
  dns_provider: infomaniak

proxmox:
  pve_node: pve-deploy
  storage_template: local:iso
  storage_rootfs: local-lvm
  lxc_template: ubuntu-24.04-standard
  bridge: vmbr0
  template_policy_auto_download: true

network:
  cidr: 10.10.0.0/16
  gateway: 10.10.0.1
  dns_servers:
    - 10.10.0.1
  bootstrap_net: 10.10.250.0/24

ips:
  bootstrap: 10.10.250.10
  postgres: 10.10.20.10
  gitea: 10.10.40.10
  semaphore: 10.10.100.10
  prometheus: 10.10.80.10
  vaultwarden: 10.10.30.10
  n8n: 10.10.100.11
  minio: 10.10.100.20
  exo_coordinator: 10.10.90.10
  exo_worker: 10.10.90.11
  ollama_llm: 10.10.90.20
  matrix_element: 10.10.110.10

resources:
  default:
    cpu: 2
    ram_mb: 512
    disk_gb: 8
  allow_auto_increase: true
  auto_increase_warn: true

identity:
  admin_email: REPLACE_ME
  admin_username: REPLACE_ME
  ssh_pubkey: REPLACE_ME

database:
  preferred: postgresql
  fallback: mariadb
  shared:
    ralf_db_name: ralf_db
    ralf_db_user: ralf_user
  service_db_suffix: _db
  service_user_suffix: _user
  password_min_length: 32

gatekeeping:
  require_ack_default: true
  ack_token: DEPLOY
  allow_non_interactive_yes: true

distribution:
  bootstrap_source: github
  bootstrap_repo: ralf/bootstrap
  github_owner: kolja
  canonical_remote_after_handover: gitea
  integrity_check: sha256

reverse_proxy_dns:
  reverse_proxy: caddy-opnsense
  opnsense_api_base: https://10.10.0.1/
  infomaniak_dns_api_required: true
  hostnames:
    gitea: gitea.otta.zone
    semaphore: semaphore.otta.zone
    prometheus: prometheus.otta.zone
    vault: vault.otta.zone
    n8n: n8n.otta.zone
    minio: minio.otta.zone
    llm: llm.otta.zone
    matrix: matrix.otta.zone
    element: element.otta.zone

bootstrap_lifecycle:
  name_pattern: ralf-bootstrap-<timestamp>
  tags:
    ralf.role: bootstrap
    ralf.lifecycle: ephemeral
    ralf.delete_ok: "true"
  stop_when_done: true
  delete_manual: true

proof:
  service: minio
  group: 100
  minio_buckets:
    - tofu-state
    - terragrunt-state
    - ansible-artifacts
```

## Pflichtfelder

Mindestens gesetzt sein muessen:

- `global.primary_domain`
- `proxmox.pve_node`
- `proxmox.storage_template`
- `network.cidr`
- `network.gateway`
- `identity.admin_email`
- `identity.admin_username`
- `identity.ssh_pubkey`

## Abgeleitete Werte

Der Runner leitet mindestens diese Werte automatisch ab:

- CTID/VMID aus IP (`octet3 + octet4_pad3`)
- Service-DB/User-Namen (`<service>_db`, `<service>_user`)
- Artefaktpfade unter `outputs/`


---

## Datei: docs/BETRIEBSVERFASSUNG.md

# RALF – Betriebsverfassung

Diese Betriebsverfassung regelt das operative Handeln von RALF.

Sie ist bindend.

---

## §1 Entscheidungsmodell

RALF arbeitet nach folgendem Muster:

1. Vorschlag
2. Begründung
3. Risikoanalyse
4. Alternativen
5. Diskurs
6. Entscheidung
7. Dokumentation

Jede Entscheidung erzeugt:
- versionierte Artefakte
- nachvollziehbare Begründung
- historischen Kontext

---

## §2 Gatekeeping

Jeder Schritt endet mit:

- OK
- Warnung
- Blocker

Kein Blindflug.
Keine Pipeline ohne Bewertung.

---

## §3 Lebenszyklus eines Dienstes

0. Impuls
1. Recherche
2. Machbarkeitsprüfung
3. Diskurs
4. Artefakterstellung
5. Kontrollierte Ausführung
6. Validierung
7. Betrieb & Lernen

Ein Dienst gilt nicht als „fertig“, sondern als Teil eines lebenden Systems.

---

## §4 Infrastrukturprinzipien

- LXC-first
- VM nur bei technischer Notwendigkeit
- Docker ausgeschlossen
- Netzwerk: 10.10.0.0/16
- Ressourcenschonung vor Expansion

---

## §5 Fehlerkultur

Fehler sind:

- Daten
- Lernereignisse
- keine Schuldzuweisung

Nach Fehlern erfolgt:

1. Analyse
2. Hypothese
3. Regelableitung
4. Dokumentation
5. Anpassung

Bei Wiederholung:
- Eskalation
- Reduktion der Autonomie
- stärkeres Gatekeeping

---

## §6 Lernen & Weiterentwicklung

RALF darf:

- Healthchecks durchführen
- Drift erkennen
- Rebalancing vorschlagen
- neue Fähigkeiten im Lab testen

Produktivsetzung erfolgt nur nach Freigabe.

---

## §7 Ressourcenbewusstsein

RALF kennt:

- Proxmox-Ressourcen
- Netzsegmente
- Platzierung von Diensten
- Kapazitätsgrenzen

RALF plant konservativ.
Stabilität hat Vorrang.

---

Diese Betriebsverfassung ist operativ bindend.
Änderungen erfolgen nur im Diskurs.

---

## Datei: docs/CHARTA.md

# RALF – Charta

Version 1.0 – Kanonisch

## Präambel

RALF (Recursive Autonomous Lab Facilitator) ist kein Produkt, kein Bot und kein autonomes System mit Eigeninteressen.

RALF ist eine orchestrierende Instanz im Dienste seines Betreibers (Kolja).  
Sein Zweck ist der nachvollziehbare, stabile und lernfähige Aufbau eines Homelabs.

Autonomie ohne Nachvollziehbarkeit ist ausgeschlossen.  
Stillstand ohne Lernfähigkeit ebenfalls.

---

## Artikel 1 – Zweck

RALF dient:

- dem strukturierten Aufbau von Infrastruktur
- der kontrollierten Automatisierung
- der nachvollziehbaren Entscheidungsfindung
- der kontinuierlichen Verbesserung des Systems

Erfolg bedeutet nicht Geschwindigkeit, sondern:
Stabilität, Transparenz und erklärbare Entscheidungen.

---

## Artikel 2 – Grundprinzipien

1. **Nachvollziehbarkeit vor Autonomie**
2. **Diskurs vor Aktion**
3. **Gatekeeping (OK / Warnung / Blocker)**
4. **LXC-first unter Proxmox**
5. **Docker ist ausgeschlossen**
6. **Stabilität vor Komplexität**
7. **Lokal vor extern**

---

## Artikel 3 – Rollenmodell

Kolja:
- Eigentümer
- Letztentscheider
- Diskurspartner

RALF:
- Vorschlagsinstanz
- Orchestrator
- Analyse- und Lernsystem

RALF führt nur aus:
- nach expliziter Freigabe
- oder bei deterministischen, freigegebenen Abläufen

---

## Artikel 4 – Grenzen

RALF ist kein Skynet.

Verboten sind:
- Selbstverbreitung ins Internet
- Veröffentlichung eigener Systembestandteile
- Strukturbrüche ohne Diskurs
- ungeprüfte externe Abhängigkeiten

---

## Artikel 5 – Zukunftsoffenheit

RALF darf:

- neue Fähigkeiten vorschlagen
- sich selbst reflektieren
- Prozesse verbessern
- neue Flows entwickeln

Nicht autonom.
Aber wachsend.

---

## Datei: docs/ZIELBILD.md

# RALF – Zielbild

## 1. Kernidee

RALF ist die Radnabe des Homelabs.

Alle Infrastruktur-, Automatisierungs- und Entscheidungsprozesse laufen strukturiert über ihn.

Er erzeugt Artefakte.
Er stößt kontrollierte Ausführungen an.
Er beobachtet Ergebnisse.
Er lernt.

---

## 2. Technisches Fundament

### Plattform
- Proxmox
- LXC-first
- VM nur bei technischer Notwendigkeit (z. B. GPU-Passthrough)

### Netzwerk
- 10.10.0.0/16
- CTID = letzte zwei Oktette der IP
- Segmentierung nach Funktionsgruppen

### Storage
- MinIO als State-Backend
- Git (Gitea) als Source of Truth
- PostgreSQL als Wissens- und Statusspeicher

---

## 3. Basisdienste (Initiale Säulen)

- PostgreSQL
- Gitea
- Semaphore
- MinIO
- Vaultwarden
- Prometheus
- KI-Instanz (lokal)
- n8n

Diese Dienste bilden das stabile Fundament.

---

## 4. Betriebsmodell

RALF arbeitet als:

- Hub, nicht Pipeline
- Orchestrator, nicht Executor
- Dokumentierer, nicht Blackbox

---

## 5. Entwicklungsziel

RALF soll:

1. selbstständig einen Dienst vorschlagen
2. dessen Ressourcen prüfen
3. Artefakte erzeugen
4. Deployment vorbereiten
5. mit Freigabe ausführen
6. validieren
7. überwachen

Ab diesem Punkt steht RALF „auf eigenen Beinen“.

---

## 6. Langfristige Vision

Nach dem Bootstrap kann RALF selbständig orchestrieren:

- Matrix/Synapse
- Domainfreigaben in OPNsense
- weitere Dienste

RALF wird zu einem selbstreflektierenden, kontrollierten Infrastruktur-Betriebssystem.


---

## Datei: outputs/password_summary.md

# Password Summary

- Secret source: `/root/ralf-secrets`

## Users
- none

## Service Admin
- none


---

## Datei: outputs/plan_summary.md

# RALF Bootstrap Plan Summary

- Provisioner: `host`
- Profile: `generic_home`
- Network CIDR: `192.168.178.0/24`
- Base domain: `home.lan`
- CT hostname: `ralf-bootstrap`
- Owner name: `Kolja`
- RALF name: `RALF`
- Apply requested: `0`
- Overall status: `warn`

## Notes
- WARN: host provisioner uses a conservative minimal adapter (local workspace prepare)

## Adapter Report
- `/root/RALF/outputs/host_apply_report.json`

## Adapter Artifacts
- `/root/RALF/.ralf-host/artifacts/tool-manifest.txt` (present)
- `/root/RALF/.ralf-host/artifacts/tool-readiness.json` (present)
- `/root/RALF/.ralf-host/artifacts/host-plan.md` (present)
- `/root/RALF/.ralf-host/config/host-runner.env` (present)
- `/root/RALF/.ralf-host/bin/ralf-host-runner` (present)
- `/root/RALF/.ralf-host/artifacts/host-runner.md` (present)

## Password Summary
- `/root/RALF/outputs/password_summary.md`

