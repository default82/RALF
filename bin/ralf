#!/usr/bin/env bash
set -euo pipefail

json_escape() {
  local s="${1:-}"
  s="${s//\\/\\\\}"
  s="${s//\"/\\\"}"
  s="${s//$'\n'/\\n}"
  s="${s//$'\r'/\\r}"
  s="${s//$'\t'/\\t}"
  printf '%s' "$s"
}

load_simple_yaml() {
  local file="$1" prefix="$2"
  [[ -f "$file" ]] || return 0
  while IFS= read -r line || [[ -n "$line" ]]; do
    line="${line%%#*}"
    [[ -n "${line//[[:space:]]/}" ]] || continue
    [[ "$line" == *:* ]] || continue
    local key="${line%%:*}"
    local val="${line#*:}"
    key="$(printf '%s' "$key" | sed 's/[[:space:]]//g')"
    val="$(printf '%s' "$val" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')"
    val="${val%\"}"; val="${val#\"}"
    val="${val%\'}"; val="${val#\'}"
    printf -v "${prefix}${key}" '%s' "$val"
  done <"$file"
}

usage() {
  cat <<'EOF'
Usage:
  ralf bootstrap [options]

Options:
  --provisioner proxmox_pct|host|lxd
  --profile NAME
  --network-cidr CIDR
  --base-domain DOMAIN
  --ct-hostname NAME
  --owner-name NAME
  --ralf-name NAME
  --host-pve-env PATH
  --ssh-privkey-file PATH
  --ssh-pubkey-file PATH
  --tui | --no-tui
  --non-interactive
  --yes
  --force
  --answers-file PATH
  --export-answers PATH
  --outputs-dir PATH
  --apply
EOF
}

cmd="${1:-}"
shift || true
[[ -n "$cmd" ]] || { usage; exit 2; }

case "$cmd" in
  bootstrap) ;;
  -h|--help|help) usage; exit 0 ;;
  *) echo "unknown command: $cmd" >&2; usage; exit 2 ;;
esac

PROVISIONER="${PROVISIONER:-}"
PROFILE="${PROFILE:-generic_home}"
NETWORK_CIDR="${NETWORK_CIDR:-}"
BASE_DOMAIN="${BASE_DOMAIN:-}"
CT_HOSTNAME="${CT_HOSTNAME:-}"
OWNER_NAME="${OWNER_NAME:-}"
RALF_NAME="${RALF_NAME:-}"
HOST_PVE_ENV="${HOST_PVE_ENV:-}"
SSH_PRIVKEY_FILE="${SSH_PRIVKEY_FILE:-}"
SSH_PUBKEY_FILE="${SSH_PUBKEY_FILE:-}"
TUI_SET=0
if [[ -n "${TUI+x}" ]]; then TUI_SET=1; fi
TUI="${TUI:-}"
NON_INTERACTIVE="${NON_INTERACTIVE:-0}"
YES="${YES:-0}"
FORCE="${FORCE:-0}"
ANSWERS_FILE="${ANSWERS_FILE:-}"
EXPORT_ANSWERS="${EXPORT_ANSWERS:-}"
OUTPUTS_DIR="${OUTPUTS_DIR:-}"
APPLY="${APPLY:-0}"

while [[ $# -gt 0 ]]; do
  case "$1" in
    --provisioner) PROVISIONER="${2:-}"; shift 2 ;;
    --profile) PROFILE="${2:-}"; shift 2 ;;
    --network-cidr) NETWORK_CIDR="${2:-}"; shift 2 ;;
    --base-domain) BASE_DOMAIN="${2:-}"; shift 2 ;;
    --ct-hostname) CT_HOSTNAME="${2:-}"; shift 2 ;;
    --owner-name) OWNER_NAME="${2:-}"; shift 2 ;;
    --ralf-name) RALF_NAME="${2:-}"; shift 2 ;;
    --host-pve-env) HOST_PVE_ENV="${2:-}"; shift 2 ;;
    --ssh-privkey-file) SSH_PRIVKEY_FILE="${2:-}"; shift 2 ;;
    --ssh-pubkey-file) SSH_PUBKEY_FILE="${2:-}"; shift 2 ;;
    --tui) TUI=1; shift ;;
    --no-tui) TUI=0; TUI_SET=1; shift ;;
    --non-interactive) NON_INTERACTIVE=1; shift ;;
    --yes) YES=1; shift ;;
    --force) FORCE=1; shift ;;
    --answers-file) ANSWERS_FILE="${2:-}"; shift 2 ;;
    --export-answers) EXPORT_ANSWERS="${2:-}"; shift 2 ;;
    --outputs-dir) OUTPUTS_DIR="${2:-}"; shift 2 ;;
    --apply) APPLY=1; shift ;;
    -h|--help) usage; exit 0 ;;
    *) echo "unknown option: $1" >&2; exit 2 ;;
  esac
done

repo_root="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
outputs_dir="${OUTPUTS_DIR:-${repo_root}/outputs}"
mkdir -p "$outputs_dir"

phase_probe="pending"
phase_config_merge="pending"
phase_policy="pending"
phase_provisioner="pending"
phase_artifacts="pending"
phase_apply_trigger="pending"
overall_status="ok"
exit_code=0
warnings=()
blockers=()
warnings_accepted=0

# Phase 1: Probe
phase_probe="running"
if [[ -z "$PROVISIONER" ]]; then
  if command -v pct >/dev/null 2>&1; then
    PROVISIONER="proxmox_pct"
  elif command -v lxc >/dev/null 2>&1; then
    PROVISIONER="lxd"
  else
    PROVISIONER="host"
  fi
fi

has_pct=0; command -v pct >/dev/null 2>&1 && has_pct=1
has_lxc=0; command -v lxc >/dev/null 2>&1 && has_lxc=1
has_git=0; command -v git >/dev/null 2>&1 && has_git=1
is_tty=0; [[ -t 1 ]] && is_tty=1
if [[ "$TUI_SET" == "0" ]]; then
  if [[ "$NON_INTERACTIVE" == "1" ]]; then
    TUI=0
  elif [[ "$is_tty" == "1" ]]; then
    TUI=1
  else
    TUI=0
  fi
fi
phase_probe="completed"

# Phase 2: Config merge (CLI > profile > conventions/defaults)
phase_config_merge="running"
declare -A cfg
declare -A probe
load_simple_yaml "${repo_root}/conventions/defaults.yml" "cfg_"
load_simple_yaml "${repo_root}/conventions/naming.yml" "cfg_"
load_simple_yaml "${repo_root}/profiles/${PROFILE}.yml" "cfg_"
if [[ -n "$ANSWERS_FILE" ]]; then
  load_simple_yaml "$ANSWERS_FILE" "ans_"
fi

ans_profile="${ans_profile:-${ans_PROFILE:-}}"
ans_network_cidr="${ans_network_cidr:-${ans_NETWORK_CIDR:-}}"
ans_base_domain="${ans_base_domain:-${ans_BASE_DOMAIN:-}}"
ans_ct_hostname="${ans_ct_hostname:-${ans_CT_HOSTNAME:-}}"
ans_owner_name="${ans_owner_name:-${ans_OWNER_NAME:-}}"
ans_ralf_name="${ans_ralf_name:-${ans_RALF_NAME:-}}"

probe_local_secrets_dir=""
for cand in "${repo_root}/ralf-secrets" "/root/ralf-secrets" "${HOME:-}/ralf-secrets"; do
  if [[ -d "$cand" ]]; then
    probe_local_secrets_dir="$cand"
    break
  fi
done
probe[ralf_secrets_dir]="$probe_local_secrets_dir"
for cand in "${HOST_PVE_ENV:-}" "${probe_local_secrets_dir}/pve.env" "/root/ralf-secrets/pve.env"; do
  [[ -n "${cand:-}" ]] || continue
  if [[ -f "$cand" ]]; then
    probe[host_pve_env]="$cand"
    break
  fi
done
for cand in "${SSH_PRIVKEY_FILE:-}" "/root/keys/Ralf/ralf_ed25519" "/root/.ssh/ralf_ed25519"; do
  [[ -n "${cand:-}" ]] || continue
  if [[ -f "$cand" ]]; then
    probe[ssh_privkey_file]="$cand"
    break
  fi
done
for cand in "${SSH_PUBKEY_FILE:-}" \
  "${probe[ssh_privkey_file]:-}.pub" \
  "/root/keys/Ralf/ralf_ed25519.pub" \
  "/root/.ssh/ralf_ed25519.pub"; do
  [[ -n "${cand:-}" ]] || continue
  if [[ -f "$cand" ]]; then
    probe[ssh_pubkey_file]="$cand"
    break
  fi
done
if [[ -f "${probe_local_secrets_dir}/mail.env" ]]; then
  probe[base_domain]="$(awk -F= '/^MAIL_DOMAIN=/{print $2; exit}' "${probe_local_secrets_dir}/mail.env" 2>/dev/null || true)"
  probe[owner_name]="$(awk -F= '/^MAIL_USERS=/{print $2; exit}' "${probe_local_secrets_dir}/mail.env" 2>/dev/null | awk '{print $1}' || true)"
fi
if [[ -z "${probe[owner_name]:-}" && -f "${probe_local_secrets_dir}/semaphore.env" ]]; then
  probe[owner_name]="$(awk -F= '/^SEMAPHORE_ADMIN_NAME=/{print $2; exit}' "${probe_local_secrets_dir}/semaphore.env" 2>/dev/null || true)"
fi
if [[ -f "${repo_root}/outputs/answers.yml" ]]; then
  load_simple_yaml "${repo_root}/outputs/answers.yml" "prev_"
fi
probe[base_domain]="${probe[base_domain]:-${prev_base_domain:-}}"
probe[owner_name]="${probe[owner_name]:-${prev_owner_name:-}}"
probe[ralf_name]="${prev_ralf_name:-ralf}"

cfg[profile]="${PROFILE:-${ans_profile:-${cfg_PROFILE_NAME:-generic_home}}}"
cfg[provisioner]="${PROVISIONER}"
cfg[network_cidr]="${NETWORK_CIDR:-${ans_network_cidr:-${cfg_NETWORK_CIDR:-}}}"
cfg[base_domain]="${BASE_DOMAIN:-${ans_base_domain:-${probe[base_domain]:-${cfg_BASE_DOMAIN:-}}}}"
cfg[ct_hostname]="${CT_HOSTNAME:-${ans_ct_hostname:-${cfg_CT_HOSTNAME:-}}}"
cfg[owner_name]="${OWNER_NAME:-${ans_owner_name:-${probe[owner_name]:-}}}"
cfg[ralf_name]="${RALF_NAME:-${ans_ralf_name:-${probe[ralf_name]:-ralf}}}"
cfg[host_pve_env]="${HOST_PVE_ENV:-${probe[host_pve_env]:-${probe_local_secrets_dir}/pve.env}}"
cfg[ssh_privkey_file]="${SSH_PRIVKEY_FILE:-${probe[ssh_privkey_file]:-/root/keys/Ralf/ralf_ed25519}}"
cfg[ssh_pubkey_file]="${SSH_PUBKEY_FILE:-${probe[ssh_pubkey_file]:-${SSH_PUBKEY_FILE:-}}}"
cfg[ralf_secrets_dir]="${probe_local_secrets_dir:-}"
[[ -z "${cfg[ssh_pubkey_file]}" && -n "${cfg[ssh_privkey_file]}" ]] && cfg[ssh_pubkey_file]="${cfg[ssh_privkey_file]}.pub"
cfg[tui_requested]="${TUI}"
cfg[tui]="${TUI}"
cfg[non_interactive]="${NON_INTERACTIVE}"
cfg[yes]="${YES}"
cfg[force]="${FORCE}"
cfg[answers_file]="${ANSWERS_FILE}"
cfg[export_answers]="${EXPORT_ANSWERS}"
cfg[outputs_dir]="${OUTPUTS_DIR}"
cfg[apply]="${APPLY}"
phase_config_merge="completed"

prompt_with_default() {
  local prompt="$1" def="${2:-}" out=""
  local tty_in=0
  [[ -r /dev/tty ]] && tty_in=1
  if [[ -n "$def" ]]; then
    if [[ "$tty_in" == "1" ]]; then
      read -r -p "$prompt [$def]: " out </dev/tty || true
    else
      read -r -p "$prompt [$def]: " out || true
    fi
    printf '%s' "${out:-$def}"
  else
    if [[ "$tty_in" == "1" ]]; then
      read -r -p "$prompt: " out </dev/tty || true
    else
      read -r -p "$prompt: " out || true
    fi
    printf '%s' "$out"
  fi
}

tui_yesno() {
  local backend="$1" title="$2" message="$3"
  case "$backend" in
    dialog)
      dialog --title "$title" --yesno "$message" 14 78 </dev/tty >/dev/tty
      ;;
    whiptail)
      whiptail --title "$title" --yesno "$message" 14 78 </dev/tty >/dev/tty 2>&1
      ;;
    *)
      printf '%s [y/N]: ' "$message" >/dev/tty
      local ans=""
      read -r ans </dev/tty || true
      [[ "$ans" =~ ^[Yy]$ ]]
      ;;
  esac
}

tui_menu() {
  local backend="$1" title="$2" prompt="$3"; shift 3
  local rc=0 out=""
  case "$backend" in
    dialog)
      out="$(dialog --stdout --title "$title" --menu "$prompt" 20 90 10 "$@" </dev/tty)" || rc=$?
      ;;
    whiptail)
      out="$(whiptail --title "$title" --menu "$prompt" 20 90 10 "$@" 3>&1 1>&2 2>&3 </dev/tty)" || rc=$?
      ;;
    *)
      printf '%s\n' "$prompt" >/dev/tty
      local i=1
      while [[ $# -gt 1 ]]; do
        printf '  %s) %s\n' "$i" "$2" >/dev/tty
        shift 2; i=$((i+1))
      done
      printf 'Auswahl [1]: ' >/dev/tty
      local ans=""
      read -r ans </dev/tty || true
      out="${ans:-1}"
      ;;
  esac
  if [[ "$rc" -ne 0 ]]; then
    TUI_CANCELLED=1
    printf ''
    return
  fi
  printf '%s' "$out"
}

tui_textbox_file() {
  local backend="$1" title="$2" file="$3"
  [[ -f "$file" ]] || return 0
  case "$backend" in
    dialog)
      dialog --title "$title" --textbox "$file" 24 100 </dev/tty >/dev/tty || true
      ;;
    whiptail)
      whiptail --title "$title" --textbox "$file" 24 100 </dev/tty >/dev/tty 2>&1 || true
      ;;
    *)
      echo; echo "$title"; cat "$file"; echo
      ;;
  esac
}

mask_value() {
  local v="${1:-}"
  local n=${#v}
  if [[ "$n" -le 4 ]]; then printf '****'; return; fi
  printf '%s****%s' "${v:0:2}" "${v:n-2:2}"
}

file_status_label() {
  local p="${1:-}"
  [[ -n "$p" ]] || { printf 'missing'; return; }
  [[ -f "$p" ]] && printf 'found' || printf 'missing'
}

ensure_ssh_keypair() {
  local priv="$1" pub="${2:-}"
  [[ -n "$priv" ]] || return 1
  [[ -n "$pub" ]] || pub="${priv}.pub"
  mkdir -p "$(dirname "$priv")"
  chmod 700 "$(dirname "$priv")" 2>/dev/null || true
  if [[ ! -f "$priv" ]]; then
    ssh-keygen -q -t ed25519 -N "" -f "$priv" </dev/null >/dev/null
  fi
  [[ -f "$pub" ]] || ssh-keygen -y -f "$priv" > "$pub"
  chmod 600 "$priv" 2>/dev/null || true
  chmod 644 "$pub" 2>/dev/null || true
}

copy_file_into_place() {
  local src="$1" dst="$2" mode="${3:-600}"
  [[ -f "$src" ]] || return 1
  [[ -n "$dst" ]] || return 1
  mkdir -p "$(dirname "$dst")"
  cp -f "$src" "$dst"
  chmod "$mode" "$dst" 2>/dev/null || true
}

choose_source_file_for_import() {
  local backend="$1" title="$2" default_path="$3"; shift 3
  local choice="" custom="" selected=""
  local menu_args=()
  local idx=1
  while [[ $# -gt 0 ]]; do
    menu_args+=("$idx" "$1")
    shift
    idx=$((idx+1))
  done
  menu_args+=("$idx" "Benutzerdefinierter Pfad")
  choice="$(tui_menu "$backend" "$title" "Quelldatei waehlen" "${menu_args[@]}")"
  [[ "$TUI_CANCELLED" == "1" ]] && return 1
  if [[ "$choice" == "$idx" ]]; then
    custom="$(tui_input_with_default "$backend" 'Quelldatei Pfad' "$default_path")"
    [[ "$TUI_CANCELLED" == "1" ]] && return 1
    selected="$custom"
  else
    selected="${menu_args[$(( (choice-1)*2 + 1 ))]}"
  fi
  printf '%s' "$selected"
}

prepare_tui_sources_review() {
  local out="$1"
  cat >"$out" <<EOF
RALF Bootstrap Quellen / Voraussetzungen

Secrets-Verzeichnis: ${cfg[ralf_secrets_dir]:-${probe_local_secrets_dir:-<leer>}} [$(file_status_label "${cfg[ralf_secrets_dir]:-${probe_local_secrets_dir:-}}")]
Proxmox pve.env:     ${cfg[host_pve_env]:-<leer>} [$(file_status_label "${cfg[host_pve_env]:-}")]
SSH Private Key:     ${cfg[ssh_privkey_file]:-<leer>} [$(file_status_label "${cfg[ssh_privkey_file]:-}")]
SSH Public Key:      ${cfg[ssh_pubkey_file]:-<leer>} [$(file_status_label "${cfg[ssh_pubkey_file]:-}")]

Erkannte Werte:
- Domain:      ${cfg[base_domain]:-<leer>}
- Owner:       ${cfg[owner_name]:-<leer>}
- RALF Name:   ${cfg[ralf_name]:-<leer>}
EOF
}

tui_configure_sources() {
  local backend="$1" choice custom review_file
  review_file="$(mktemp)"
  while true; do
    [[ -z "${cfg[ssh_pubkey_file]}" && -n "${cfg[ssh_privkey_file]}" ]] && cfg[ssh_pubkey_file]="${cfg[ssh_privkey_file]}.pub"
    prepare_tui_sources_review "$review_file"
    tui_textbox_file "$backend" "RALF Quellen" "$review_file"
    choice="$(tui_menu "$backend" "RALF Quellen" "Aktion waehlen" \
      1 "Weiter" \
      2 "Secrets-Verzeichnis Pfad setzen" \
      3 "pve.env Pfad setzen" \
      4 "SSH-Key Pfad waehlen/eingeben" \
      5 "SSH-Key fuer ralf generieren" \
      6 "pve.env Datei importieren/ersetzen" \
      7 "SSH Private Key importieren/ersetzen" \
      8 "SSH Public Key importieren/ersetzen" \
      9 "Werte (Domain/Namen) bearbeiten")"
    [[ "$TUI_CANCELLED" == "1" ]] && break
    case "$choice" in
      1) break ;;
      2)
        custom="$(tui_input_with_default "$backend" 'Pfad zum ralf-secrets Verzeichnis' "${cfg[ralf_secrets_dir]:-${probe_local_secrets_dir:-/root/ralf-secrets}}")"
        cfg[ralf_secrets_dir]="$custom"
        [[ -z "${cfg[host_pve_env]}" && -n "$custom" ]] && cfg[host_pve_env]="$custom/pve.env"
        ;;
      3)
        custom="$(tui_input_with_default "$backend" 'Pfad zur Proxmox pve.env' "${cfg[host_pve_env]:-${cfg[ralf_secrets_dir]:-/root/ralf-secrets}/pve.env}")"
        cfg[host_pve_env]="$custom"
        ;;
      4)
        choice="$(tui_menu "$backend" "SSH-Key fuer ralf" "Quelle waehlen" \
          1 "Auto/aktuellen Pfad behalten" \
          2 "/root/keys/Ralf/ralf_ed25519" \
          3 "/root/.ssh/ralf_ed25519" \
          4 "Benutzerdefinierter Pfad")"
        [[ "$TUI_CANCELLED" == "1" ]] && break
        case "$choice" in
          1) ;;
          2) cfg[ssh_privkey_file]="/root/keys/Ralf/ralf_ed25519"; cfg[ssh_pubkey_file]="/root/keys/Ralf/ralf_ed25519.pub" ;;
          3) cfg[ssh_privkey_file]="/root/.ssh/ralf_ed25519"; cfg[ssh_pubkey_file]="/root/.ssh/ralf_ed25519.pub" ;;
          4)
            custom="$(tui_input_with_default "$backend" 'SSH Private Key Pfad' "${cfg[ssh_privkey_file]:-/root/keys/Ralf/ralf_ed25519}")"
            cfg[ssh_privkey_file]="$custom"
            cfg[ssh_pubkey_file]="${custom}.pub"
            ;;
        esac
        custom="$(tui_input_with_default "$backend" 'SSH Public Key Pfad (optional)' "${cfg[ssh_pubkey_file]:-${cfg[ssh_privkey_file]}.pub}")"
        cfg[ssh_pubkey_file]="$custom"
        ;;
      5)
        custom="$(tui_input_with_default "$backend" 'Zielpfad fuer neuen SSH Private Key' "${cfg[ssh_privkey_file]:-/root/keys/Ralf/ralf_ed25519}")"
        cfg[ssh_privkey_file]="$custom"
        cfg[ssh_pubkey_file]="${custom}.pub"
        if ensure_ssh_keypair "${cfg[ssh_privkey_file]}" "${cfg[ssh_pubkey_file]}"; then
          tui_show_info "$backend" "SSH-Key erzeugt" "SSH-Keypaar wurde erzeugt:\n${cfg[ssh_privkey_file]}\n${cfg[ssh_pubkey_file]}"
        else
          tui_show_info "$backend" "SSH-Key Fehler" "SSH-Key konnte nicht erzeugt werden."
        fi
        ;;
      6)
        custom="$(choose_source_file_for_import "$backend" "pve.env importieren" "${cfg[host_pve_env]:-${cfg[ralf_secrets_dir]:-/root/ralf-secrets}/pve.env}" \
          "/root/ralf-secrets/pve.env" \
          "${cfg[ralf_secrets_dir]:-/root/ralf-secrets}/pve.env")" || true
        [[ "$TUI_CANCELLED" == "1" ]] && break
        if [[ -n "$custom" ]]; then
          local dst_pve="${cfg[host_pve_env]:-${cfg[ralf_secrets_dir]:-/root/ralf-secrets}/pve.env}"
          if copy_file_into_place "$custom" "$dst_pve" 600; then
            cfg[host_pve_env]="$dst_pve"
            tui_show_info "$backend" "Import ok" "pve.env wurde ersetzt:\n$dst_pve"
          else
            tui_show_info "$backend" "Import Fehler" "pve.env Import fehlgeschlagen."
          fi
        fi
        ;;
      7)
        custom="$(choose_source_file_for_import "$backend" "SSH Private Key importieren" "${cfg[ssh_privkey_file]:-/root/keys/Ralf/ralf_ed25519}" \
          "/root/keys/Ralf/ralf_ed25519" \
          "/root/.ssh/ralf_ed25519")" || true
        [[ "$TUI_CANCELLED" == "1" ]] && break
        if [[ -n "$custom" ]]; then
          local dst_priv="${cfg[ssh_privkey_file]:-/root/keys/Ralf/ralf_ed25519}"
          if copy_file_into_place "$custom" "$dst_priv" 600; then
            cfg[ssh_privkey_file]="$dst_priv"
            [[ -n "${cfg[ssh_pubkey_file]}" ]] || cfg[ssh_pubkey_file]="${dst_priv}.pub"
            [[ -f "${cfg[ssh_pubkey_file]}" ]] || ssh-keygen -y -f "$dst_priv" > "${cfg[ssh_pubkey_file]}" 2>/dev/null || true
            tui_show_info "$backend" "Import ok" "SSH Private Key wurde ersetzt:\n$dst_priv"
          else
            tui_show_info "$backend" "Import Fehler" "SSH Private Key Import fehlgeschlagen."
          fi
        fi
        ;;
      8)
        custom="$(choose_source_file_for_import "$backend" "SSH Public Key importieren" "${cfg[ssh_pubkey_file]:-${cfg[ssh_privkey_file]:-/root/keys/Ralf/ralf_ed25519}.pub}" \
          "/root/keys/Ralf/ralf_ed25519.pub" \
          "/root/.ssh/ralf_ed25519.pub")" || true
        [[ "$TUI_CANCELLED" == "1" ]] && break
        if [[ -n "$custom" ]]; then
          local dst_pub="${cfg[ssh_pubkey_file]:-${cfg[ssh_privkey_file]:-/root/keys/Ralf/ralf_ed25519}.pub}"
          if copy_file_into_place "$custom" "$dst_pub" 644; then
            cfg[ssh_pubkey_file]="$dst_pub"
            tui_show_info "$backend" "Import ok" "SSH Public Key wurde ersetzt:\n$dst_pub"
          else
            tui_show_info "$backend" "Import Fehler" "SSH Public Key Import fehlgeschlagen."
          fi
        fi
        ;;
      9)
        cfg[base_domain]="$(tui_input_with_default "$backend" 'Lab DNS / Base-Domain' "${cfg[base_domain]}")"
        cfg[owner_name]="$(tui_input_with_default "$backend" 'Dein Name (Primary User)' "${cfg[owner_name]}")"
        cfg[ralf_name]="$(tui_input_with_default "$backend" 'RALF Name' "${cfg[ralf_name]}")"
        ;;
    esac
  done
  rm -f "$review_file"
}

tui_backend_detect() {
  if [[ "$is_tty" != "1" || "${cfg[non_interactive]}" == "1" || "${cfg[tui]}" != "1" ]]; then
    printf 'none'
    return
  fi
  if command -v dialog >/dev/null 2>&1 && [[ -r /dev/tty ]]; then
    printf 'dialog'
    return
  fi
  if command -v whiptail >/dev/null 2>&1 && [[ -r /dev/tty ]]; then
    printf 'whiptail'
    return
  fi
  printf 'prompt'
}

tui_show_info() {
  local backend="$1" title="$2" message="$3"
  case "$backend" in
    dialog)
      dialog --stdout --title "$title" --msgbox "$message" 16 78 </dev/tty >/dev/tty || true
      ;;
    whiptail)
      whiptail --title "$title" --msgbox "$message" 16 78 </dev/tty >/dev/tty 2>&1 || true
      ;;
    *)
      echo
      echo "$title"
      printf '%s\n' "$message"
      echo
      ;;
  esac
}

tui_input_with_default() {
  local backend="$1" label="$2" def="${3:-}" out="" rc=0
  case "$backend" in
    dialog)
      out="$(dialog --stdout --title "RALF Bootstrap" --inputbox "$label" 10 78 "$def" </dev/tty)" || rc=$?
      ;;
    whiptail)
      out="$(whiptail --title "RALF Bootstrap" --inputbox "$label" 10 78 "$def" 3>&1 1>&2 2>&3 </dev/tty)" || rc=$?
      ;;
    *)
      out="$(prompt_with_default "$label" "$def")" || true
      ;;
  esac
  if [[ "$rc" -ne 0 ]]; then
    TUI_CANCELLED=1
    printf '%s' "$def"
    return
  fi
  if [[ -z "$out" && -n "$def" ]]; then
    printf '%s' "$def"
  else
    printf '%s' "$out"
  fi
}

TUI_CANCELLED=0
tui_backend="none"
if [[ "${cfg[tui]}" == "1" && "${cfg[non_interactive]}" != "1" && "$is_tty" == "1" ]]; then
  tui_backend="$(tui_backend_detect)"
  cfg[ralf_secrets_dir]="${cfg[ralf_secrets_dir]:-${probe_local_secrets_dir:-}}"
  tui_configure_sources "$tui_backend"
  [[ -z "${cfg[ssh_pubkey_file]}" && -n "${cfg[ssh_privkey_file]}" ]] && cfg[ssh_pubkey_file]="${cfg[ssh_privkey_file]}.pub"
  [[ -n "${cfg[ct_hostname]}" ]] || cfg[ct_hostname]="ralf-bootstrap"
fi

# Phase 3: Policy / Gatekeeping
phase_policy="running"
case "${cfg[provisioner]}" in
  proxmox_pct|host|lxd) ;;
  *)
    blockers+=("Unsupported provisioner: ${cfg[provisioner]}")
    ;;
esac

if [[ "${cfg[non_interactive]}" == "1" ]]; then
  [[ "${cfg[tui]}" == "1" ]] && warnings+=("NON_INTERACTIVE=1 disables TUI")
  cfg[tui]=0
  [[ -n "${cfg[profile]}" ]] || blockers+=("Missing required value: profile")
fi
if [[ "${cfg[tui]}" == "1" && "$is_tty" != "1" ]]; then
  cfg[tui]=0
  warnings+=("TUI requested but no TTY is available; disabling TUI")
fi
if [[ "$TUI_CANCELLED" == "1" ]]; then
  blockers+=("TUI canceled by user")
fi
if [[ -n "${cfg[answers_file]}" && ! -f "${cfg[answers_file]}" ]]; then
  blockers+=("ANSWERS_FILE not found: ${cfg[answers_file]}")
fi

if [[ "${cfg[provisioner]}" == "host" ]]; then
  warnings+=("host provisioner uses a conservative minimal adapter (local workspace prepare)")
fi
if [[ "${cfg[provisioner]}" == "lxd" ]]; then
  warnings+=("lxd provisioner uses a conservative minimal adapter (create-if-missing)")
fi

if [[ ${#blockers[@]} -gt 0 ]]; then
  overall_status="blocker"
  exit_code=2
elif [[ ${#warnings[@]} -gt 0 ]]; then
  if [[ "${cfg[yes]}" == "1" ]]; then
    warnings_accepted=1
    overall_status="ok"
    exit_code=0
  else
    overall_status="warn"
    exit_code=1
  fi
fi
phase_policy="completed"

# Phase 4: Provisioner selection (adapter resolution)
phase_provisioner="running"
provisioner_adapter=""
case "${cfg[provisioner]}" in
  proxmox_pct) provisioner_adapter="${repo_root}/bootstrap/adapters/proxmox_pct.sh" ;;
  host) provisioner_adapter="${repo_root}/bootstrap/adapters/host.sh" ;;
  lxd) provisioner_adapter="${repo_root}/bootstrap/adapters/lxd.sh" ;;
esac
phase_provisioner="completed"

# Phase 5: Artifact generation (always)
phase_artifacts="running"

cat >"${outputs_dir}/probe_report.json" <<EOF
{
  "provisioner_detected": "$(json_escape "${cfg[provisioner]}")",
  "existing_info": {
    "local_secrets_dir": "$(json_escape "${probe_local_secrets_dir}")",
    "selected_secrets_dir": "$(json_escape "${cfg[ralf_secrets_dir]:-}")",
    "host_pve_env": "$(json_escape "${probe[host_pve_env]:-}")",
    "ssh_privkey_file": "$(json_escape "${probe[ssh_privkey_file]:-}")",
    "ssh_pubkey_file": "$(json_escape "${probe[ssh_pubkey_file]:-}")",
    "base_domain": "$(json_escape "${probe[base_domain]:-}")",
    "owner_name": "$(json_escape "${probe[owner_name]:-}")",
    "ralf_name": "$(json_escape "${probe[ralf_name]:-}")"
  },
  "commands": {
    "pct": ${has_pct},
    "lxc": ${has_lxc},
    "git": ${has_git}
  },
  "tty": ${is_tty}
  ,"tui_backend": "$(json_escape "${tui_backend}")"
}
EOF

cat >"${outputs_dir}/final_config.json" <<EOF
{
  "provisioner": "$(json_escape "${cfg[provisioner]}")",
  "profile": "$(json_escape "${cfg[profile]}")",
  "network_cidr": "$(json_escape "${cfg[network_cidr]}")",
  "base_domain": "$(json_escape "${cfg[base_domain]}")",
  "ct_hostname": "$(json_escape "${cfg[ct_hostname]}")",
  "owner_name": "$(json_escape "${cfg[owner_name]}")",
  "ralf_name": "$(json_escape "${cfg[ralf_name]}")",
  "host_pve_env": "$(json_escape "${cfg[host_pve_env]}")",
  "ralf_secrets_dir": "$(json_escape "${cfg[ralf_secrets_dir]}")",
  "ssh_privkey_file": "$(json_escape "${cfg[ssh_privkey_file]}")",
  "ssh_pubkey_file": "$(json_escape "${cfg[ssh_pubkey_file]}")",
  "tui_requested": ${cfg[tui_requested]},
  "tui": ${cfg[tui]},
  "tui_backend": "$(json_escape "${tui_backend}")",
  "non_interactive": ${cfg[non_interactive]},
  "yes": ${cfg[yes]},
  "force": ${cfg[force]},
  "apply": ${cfg[apply]}
}
EOF

{
  printf 'profile: %s\n' "${cfg[profile]}"
  printf 'provisioner: %s\n' "${cfg[provisioner]}"
  printf 'network_cidr: %s\n' "${cfg[network_cidr]}"
  printf 'base_domain: %s\n' "${cfg[base_domain]}"
  printf 'ct_hostname: %s\n' "${cfg[ct_hostname]}"
  printf 'owner_name: %s\n' "${cfg[owner_name]}"
  printf 'ralf_name: %s\n' "${cfg[ralf_name]}"
  printf 'host_pve_env: %s\n' "${cfg[host_pve_env]}"
  printf 'ralf_secrets_dir: %s\n' "${cfg[ralf_secrets_dir]}"
  printf 'ssh_privkey_file: %s\n' "${cfg[ssh_privkey_file]}"
  printf 'ssh_pubkey_file: %s\n' "${cfg[ssh_pubkey_file]}"
} > "${outputs_dir}/answers.yml"

cat >"${outputs_dir}/plan_summary.md" <<EOF
# RALF Bootstrap Plan Summary

- Provisioner: \`${cfg[provisioner]}\`
- Profile: \`${cfg[profile]}\`
- Network CIDR: \`${cfg[network_cidr]:-<unset>}\`
- Base domain: \`${cfg[base_domain]:-<unset>}\`
- CT hostname: \`${cfg[ct_hostname]:-<unset>}\`
- Owner name: \`${cfg[owner_name]:-<unset>}\`
- RALF name: \`${cfg[ralf_name]:-<unset>}\`
- Apply requested: \`${cfg[apply]}\`
- Overall status: \`${overall_status}\`

## Notes
EOF
for w in "${warnings[@]}"; do printf -- '- WARN: %s\n' "$w"; done >> "${outputs_dir}/plan_summary.md"
for b in "${blockers[@]}"; do printf -- '- BLOCKER: %s\n' "$b"; done >> "${outputs_dir}/plan_summary.md"
[[ ${#warnings[@]} -eq 0 && ${#blockers[@]} -eq 0 ]] && printf -- '- No warnings or blockers.\n' >> "${outputs_dir}/plan_summary.md"

phase_artifacts="completed"

# Phase 6: Optional apply trigger (only explicit gate)
phase_apply_trigger="running"
applied=0
apply_result="skipped"
adapter_report_file=""
adapter_artifacts_json="[]"
case "${cfg[provisioner]}" in
  host) adapter_report_file="${outputs_dir}/host_apply_report.json" ;;
  lxd) adapter_report_file="${outputs_dir}/lxd_apply_report.json" ;;
  proxmox_pct) adapter_report_file="" ;;
esac
if [[ "${cfg[apply]}" == "1" ]]; then
  if [[ ${#blockers[@]} -gt 0 ]]; then
    apply_result="blocked"
  elif [[ -n "$provisioner_adapter" ]]; then
    if [[ -x "$provisioner_adapter" ]]; then
      # Forward merged values into the provisioner adapter environment.
      export PROFILE="${cfg[profile]}"
      export OUTPUTS_DIR="${outputs_dir}"
      [[ -n "${cfg[network_cidr]}" ]] && export NETWORK_CIDR="${cfg[network_cidr]}"
      [[ -n "${cfg[base_domain]}" ]] && export BASE_DOMAIN="${cfg[base_domain]}"
      [[ -n "${cfg[ct_hostname]}" ]] && export CT_HOSTNAME="${cfg[ct_hostname]}"
      [[ -n "${cfg[owner_name]}" ]] && export OWNER_NAME="${cfg[owner_name]}"
      [[ -n "${cfg[ralf_name]}" ]] && export RALF_NAME="${cfg[ralf_name]}"
      [[ -n "${cfg[host_pve_env]}" ]] && export HOST_PVE_ENV="${cfg[host_pve_env]}"
      [[ -n "${cfg[ssh_privkey_file]}" ]] && export SSH_PRIVKEY_FILE="${cfg[ssh_privkey_file]}"
      [[ -n "${cfg[ssh_pubkey_file]}" ]] && export SSH_PUBKEY_FILE="${cfg[ssh_pubkey_file]}"
      if [[ "${cfg[apply]}" == "1" && "${AUTO_APPLY:-0}" != "1" ]]; then export AUTO_APPLY=1; fi
      if [[ "${cfg[yes]}" == "1" && "${YES:-0}" != "1" ]]; then export YES=1; fi
      if [[ "${cfg[force]}" == "1" && "${FORCE:-0}" != "1" ]]; then export FORCE=1; fi
      set +e
      "$provisioner_adapter"
      adapter_rc=$?
      set -e
      if [[ "$adapter_rc" -eq 0 ]]; then
        applied=1
        apply_result="applied"
      else
        blockers+=("${cfg[provisioner]} adapter failed with exit code ${adapter_rc}")
        overall_status="blocker"
        exit_code=2
        apply_result="adapter_failed"
      fi
    else
      blockers+=("Missing ${cfg[provisioner]} adapter: $provisioner_adapter")
      overall_status="blocker"
      exit_code=2
      apply_result="adapter_missing"
    fi
  else
    blockers+=("No adapter configured for provisioner: ${cfg[provisioner]}")
    overall_status="blocker"
    exit_code=2
    apply_result="adapter_missing"
  fi
fi
phase_apply_trigger="completed"

# Reconcile final status after apply trigger, because adapter execution can
# promote warnings to blockers (or add new blockers).
if [[ ${#blockers[@]} -gt 0 ]]; then
  overall_status="blocker"
  exit_code=2
elif [[ ${#warnings[@]} -gt 0 ]]; then
  if [[ "${cfg[yes]}" == "1" ]]; then
    warnings_accepted=1
    overall_status="ok"
    exit_code=0
  else
    overall_status="warn"
    exit_code=1
  fi
else
  overall_status="ok"
  exit_code=0
fi

if [[ -n "$adapter_report_file" ]]; then
  {
    printf '\n## Adapter Report\n'
    if [[ -f "$adapter_report_file" ]]; then
      printf -- '- `%s`\n' "${adapter_report_file}"
    else
      printf -- '- Expected adapter report (not present): `%s`\n' "${adapter_report_file}"
    fi
  } >> "${outputs_dir}/plan_summary.md"
fi

if [[ -n "$adapter_report_file" && -f "$adapter_report_file" && "$(command -v python3 >/dev/null 2>&1; echo $?)" -eq 0 ]]; then
  adapter_artifacts_json="$(
    python3 - "$adapter_report_file" <<'PY'
import json, os, sys

report_path = sys.argv[1]
try:
    data = json.load(open(report_path))
except Exception:
    print("[]")
    sys.exit(0)

provisioner = data.get("provisioner")
keys_by_provisioner = {
    "host": [
        "tool_manifest",
        "tool_readiness_file",
        "host_plan_file",
        "host_runner_env_file",
        "host_runner_wrapper",
        "host_runner_readme",
    ],
    "lxd": [
        "plan_file",
        "metadata_preview_file",
        "metadata_applied_file",
    ],
}
items = []
for key in keys_by_provisioner.get(provisioner, []):
    p = data.get(key, "")
    if not p:
        continue
    items.append({"key": key, "path": p, "exists": os.path.exists(p)})
print(json.dumps(items))
PY
  )"

  python3 - "$adapter_report_file" >> "${outputs_dir}/plan_summary.md" <<'PY'
import json, os, sys

report_path = sys.argv[1]
try:
    data = json.load(open(report_path))
except Exception:
    sys.exit(0)

provisioner = data.get("provisioner")
keys_by_provisioner = {
    "host": [
        "tool_manifest",
        "tool_readiness_file",
        "host_plan_file",
        "host_runner_env_file",
        "host_runner_wrapper",
        "host_runner_readme",
    ],
    "lxd": [
        "plan_file",
        "metadata_preview_file",
        "metadata_applied_file",
    ],
}
keys = keys_by_provisioner.get(provisioner, [])
if not keys:
    sys.exit(0)

print("")
print("## Adapter Artifacts")
printed = 0
for key in keys:
    p = data.get(key, "")
    if not p:
        continue
    status = "present" if os.path.exists(p) else "missing"
    print(f"- `{p}` ({status})")
    printed += 1
if not printed:
    print("- No adapter artifacts listed.")
PY
fi

if [[ -n "$adapter_report_file" && ! -f "$adapter_report_file" ]]; then
  {
    printf '\n## Adapter Artifacts\n'
    if [[ "${cfg[apply]}" == "1" ]]; then
      printf -- '- Adapter report missing; no artifact list available.\n'
    else
      printf -- '- Apply not executed; no adapter artifacts were generated.\n'
    fi
  } >> "${outputs_dir}/plan_summary.md"
fi

tmp_plan="$(mktemp)"
awk -v s="$overall_status" '
  BEGIN { replaced=0 }
  /^- Overall status: `/ {
    print "- Overall status: `" s "`"
    replaced=1
    next
  }
  { print }
  END {
    if (!replaced) {
      print ""
      print "- Overall status: `" s "`"
    }
  }
' "${outputs_dir}/plan_summary.md" > "$tmp_plan"
mv "$tmp_plan" "${outputs_dir}/plan_summary.md"

cat >"${outputs_dir}/checkpoints.json" <<EOF
{
  "phases": [
    {"name":"probe","status":"${phase_probe}"},
    {"name":"config_merge","status":"${phase_config_merge}"},
    {"name":"policy_gatekeeping","status":"${phase_policy}"},
    {"name":"provisioner","status":"${phase_provisioner}"},
    {"name":"artifact_generation","status":"${phase_artifacts}"},
    {"name":"optional_apply_trigger","status":"${phase_apply_trigger}"}
  ],
  "apply_result": "$(json_escape "${apply_result}")"
}
EOF

warn_json=""
if [[ ${#warnings[@]} -gt 0 ]]; then
  warn_json="["
  for i in "${!warnings[@]}"; do
    [[ "$i" -gt 0 ]] && warn_json+=","
    warn_json+="\"$(json_escape "${warnings[$i]}")\""
  done
  warn_json+="]"
else
  warn_json="[]"
fi

blocker_json=""
if [[ ${#blockers[@]} -gt 0 ]]; then
  blocker_json="["
  for i in "${!blockers[@]}"; do
    [[ "$i" -gt 0 ]] && blocker_json+=","
    blocker_json+="\"$(json_escape "${blockers[$i]}")\""
  done
  blocker_json+="]"
else
  blocker_json="[]"
fi

cat >"${outputs_dir}/cli_status.json" <<EOF
{
  "command": "bootstrap",
  "status": "$(json_escape "${overall_status}")",
  "exit_code": ${exit_code},
  "applied": ${applied},
  "warnings_accepted": ${warnings_accepted},
  "tui_requested": ${cfg[tui_requested]},
  "tui_effective": ${cfg[tui]},
  "tui_backend": "$(json_escape "${tui_backend}")",
  "owner_name": "$(json_escape "${cfg[owner_name]}")",
  "ralf_name": "$(json_escape "${cfg[ralf_name]}")",
  "host_pve_env": "$(json_escape "${cfg[host_pve_env]}")",
  "ralf_secrets_dir": "$(json_escape "${cfg[ralf_secrets_dir]}")",
  "ssh_privkey_file": "$(json_escape "${cfg[ssh_privkey_file]}")",
  "ssh_pubkey_file": "$(json_escape "${cfg[ssh_pubkey_file]}")",
  "warnings": ${warn_json},
  "blockers": ${blocker_json},
  "adapter_report_file": "$(json_escape "${adapter_report_file}")",
  "adapter_report_exists": $( [[ -n "$adapter_report_file" && -f "$adapter_report_file" ]] && printf 'true' || printf 'false' ),
  "adapter_artifacts": ${adapter_artifacts_json},
  "outputs_dir": "$(json_escape "${outputs_dir}")"
}
EOF

generate_password_summary() {
  local out_json="$1" out_md="$2" out_masked_md="$3" selected_secret_dir="${4:-}"
  command -v python3 >/dev/null 2>&1 || return 0
  python3 - "$out_json" "$out_md" "$out_masked_md" "$repo_root" "$selected_secret_dir" <<'PY'
import json, os, sys

out_json, out_md, out_masked_md, repo_root, selected_secret_dir = sys.argv[1], sys.argv[2], sys.argv[3], sys.argv[4], sys.argv[5]
candidates = [
    selected_secret_dir,
    os.path.join(repo_root, "ralf-secrets"),
    "/root/ralf-secrets",
    os.path.join(os.environ.get("HOME",""), "ralf-secrets"),
    "/opt/ralf/runtime/secrets",
]
secret_dir = next((c for c in candidates if c and os.path.isdir(c)), None)

def read_env(path):
    d = {}
    if not path or not os.path.isfile(path):
        return d
    with open(path, encoding="utf-8", errors="ignore") as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#") or "=" not in line:
                continue
            k, v = line.split("=", 1)
            d[k] = v
    return d

data = {"secret_dir": secret_dir, "users": {}, "services": {}}
if secret_dir:
    sem = read_env(os.path.join(secret_dir, "semaphore.env"))
    if sem.get("SEMAPHORE_ADMIN_NAME") and sem.get("SEMAPHORE_ADMIN_PASSWORD"):
        data["services"]["semaphore"] = {"url":"https://10.10.40.10","user":sem["SEMAPHORE_ADMIN_NAME"],"password":sem["SEMAPHORE_ADMIN_PASSWORD"]}
    g = read_env(os.path.join(secret_dir, "gitea.env"))
    if g.get("GITEA_ADMIN_USER") and g.get("GITEA_ADMIN_PASSWORD"):
        data["services"]["gitea"] = {"url":"https://10.10.40.40","user":g["GITEA_ADMIN_USER"],"password":g["GITEA_ADMIN_PASSWORD"]}
    n = read_env(os.path.join(secret_dir, "n8n.env"))
    if n.get("N8N_BASIC_AUTH_USER") and n.get("N8N_BASIC_AUTH_PASSWORD"):
        data["services"]["n8n_basic_auth"] = {"url":"https://10.10.40.30","user":n["N8N_BASIC_AUTH_USER"],"password":n["N8N_BASIC_AUTH_PASSWORD"]}
    m = read_env(os.path.join(secret_dir, "minio.env"))
    if m.get("MINIO_ROOT_USER") and m.get("MINIO_ROOT_PASSWORD"):
        data["services"]["minio"] = {"url":"https://10.10.30.10:9001","user":m["MINIO_ROOT_USER"],"password":m["MINIO_ROOT_PASSWORD"]}
    v = read_env(os.path.join(secret_dir, "vaultwarden.env"))
    if v.get("VAULTWARDEN_ADMIN_TOKEN"):
        data["services"]["vaultwarden_admin"] = {"url":"https://10.10.40.20/admin","admin_token":v["VAULTWARDEN_ADMIN_TOKEN"]}
    mail = read_env(os.path.join(secret_dir, "mail.env"))
    if mail:
        domain = mail.get("MAIL_DOMAIN", "homelab.lan")
        for k, val in mail.items():
            if k.startswith("MAIL_PASSWORD_"):
                user = k.replace("MAIL_PASSWORD_", "").lower()
                data["users"].setdefault(user, {})["mail"] = {"email": f"{user}@{domain}", "password": val}
    syn = read_env(os.path.join(secret_dir, "synapse.env"))
    for k, val in syn.items():
        if k.startswith("SYNAPSE_ADMIN_PASSWORD_"):
            user = k.replace("SYNAPSE_ADMIN_PASSWORD_", "").lower()
            data["users"].setdefault(user, {})["matrix"] = {"user": user, "password": val}

with open(out_json, "w", encoding="utf-8") as f:
    json.dump(data, f, indent=2)

lines = ["# Password Summary", ""]
lines.append(f"- Secret source: `{secret_dir}`" if secret_dir else "- Secret source: `<not found>`")
lines.append("")
lines.append("## Users")
if data["users"]:
    for user in sorted(data["users"]):
        lines.append(f"- {user}")
        for scope, item in data["users"][user].items():
            if "email" in item:
                lines.append(f"  - {scope}: `{item['email']}` / `{item['password']}`")
            else:
                lines.append(f"  - {scope}: `{item.get('user', user)}` / `{item['password']}`")
else:
    lines.append("- none")
lines.append("")
lines.append("## Service Admin")
if data["services"]:
    for svc in sorted(data["services"]):
        item = data["services"][svc]
        if "admin_token" in item:
            lines.append(f"- {svc}: `{item['url']}` token `{item['admin_token']}`")
        else:
            lines.append(f"- {svc}: `{item['url']}` user `{item['user']}` password `{item['password']}`")
else:
    lines.append("- none")

with open(out_md, "w", encoding="utf-8") as f:
    f.write("\n".join(lines) + "\n")

def mask(v):
    if not isinstance(v, str):
        return v
    if len(v) <= 4:
        return "****"
    return v[:2] + "****" + v[-2:]

masked_lines = ["# Password Summary (Masked)", ""]
masked_lines.append(f"- Secret source: `{secret_dir}`" if secret_dir else "- Secret source: `<not found>`")
masked_lines.append("")
masked_lines.append("## Users")
if data["users"]:
    for user in sorted(data["users"]):
        masked_lines.append(f"- {user}")
        for scope, item in data["users"][user].items():
            if "email" in item:
                masked_lines.append(f"  - {scope}: `{item['email']}` / `{mask(item['password'])}`")
            else:
                masked_lines.append(f"  - {scope}: `{item.get('user', user)}` / `{mask(item['password'])}`")
else:
    masked_lines.append("- none")
masked_lines.append("")
masked_lines.append("## Service Admin")
if data["services"]:
    for svc in sorted(data["services"]):
        item = data["services"][svc]
        if "admin_token" in item:
            masked_lines.append(f"- {svc}: `{item['url']}` token `{mask(item['admin_token'])}`")
        else:
            masked_lines.append(f"- {svc}: `{item['url']}` user `{item['user']}` password `{mask(item['password'])}`")
else:
    masked_lines.append("- none")

with open(out_masked_md, "w", encoding="utf-8") as f:
    f.write("\n".join(masked_lines) + "\n")
PY
}

password_summary_json="${outputs_dir}/password_summary.json"
password_summary_md="${outputs_dir}/password_summary.md"
password_summary_masked_md="${outputs_dir}/password_summary.masked.md"
generate_password_summary "$password_summary_json" "$password_summary_md" "$password_summary_masked_md" "${cfg[ralf_secrets_dir]:-}" || true
if [[ -f "$password_summary_md" ]]; then
  {
    printf '\n## Password Summary\n'
    printf -- '- `%s`\n' "${password_summary_md}"
  } >> "${outputs_dir}/plan_summary.md"
fi

if [[ -n "$EXPORT_ANSWERS" ]]; then
  mkdir -p "$(dirname "$EXPORT_ANSWERS")"
  cp "${outputs_dir}/answers.yml" "$EXPORT_ANSWERS"
fi

if [[ -f "$password_summary_md" ]]; then
  echo
  echo "RALF Password Summary"
  if [[ -f "$password_summary_masked_md" ]]; then
    cat "$password_summary_masked_md"
    if [[ "${cfg[tui]}" == "1" && "${cfg[non_interactive]}" != "1" && "$is_tty" == "1" ]]; then
      if tui_yesno "$tui_backend" "Passwoerter anzeigen" "Klartext-Passwoerter/Secrets jetzt anzeigen?"; then
        tui_textbox_file "$tui_backend" "RALF Password Summary (Full)" "$password_summary_md"
      fi
    fi
  else
    cat "$password_summary_md"
  fi
fi

exit "${exit_code}"
