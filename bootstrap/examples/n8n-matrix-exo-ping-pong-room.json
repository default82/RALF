{
  "name": "RALF Matrix Ping Pong (All Rooms Poll)",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "seconds",
              "secondsInterval": 10
            }
          ]
        }
      },
      "id": "manual-trigger",
      "name": "Poll Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        240,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "const cfg = {\n  matrixBaseUrl: 'http://10.10.110.10:8008',\n  user: 'ralf',\n  password: 'REPLACE_WITH_RALF_PASSWORD',\n  accessToken: 'REPLACE_WITH_RALF_ACCESS_TOKEN',\n  command: '!ping',\n  replyText: '!pong',\n  pollTimeoutMs: 30000,\n  allowedRoomIds: [],\n  roomNameIncludes: [],\n  requiredTags: [],\n  allowedSenders: [],\n};\n\nasync function jfetch(url, options = {}) {\n  const method = options.method || 'GET';\n  const headers = options.headers || {};\n  const body = options.body;\n  try {\n    const resp = await this.helpers.httpRequest({\n      method,\n      url,\n      headers,\n      body,\n      json: true,\n      returnFullResponse: true,\n      ignoreHttpStatusErrors: true,\n    });\n    const statusCode = Number(resp?.statusCode || 0);\n    return { res: { ok: statusCode >= 200 && statusCode < 300, status: statusCode }, body: resp?.body || {} };\n  } catch (err) {\n    const statusCode = Number(err?.statusCode || 0);\n    return { res: { ok: false, status: statusCode }, body: err?.response?.body || { error: String(err?.message || err) } };\n  }\n}\n\nasync function getRoomName(matrixBaseUrl, token, roomId, cache) {\n  if (cache[roomId]?.name !== undefined) return cache[roomId].name;\n  const resp = await jfetch(`${matrixBaseUrl}/_matrix/client/v3/rooms/${encodeURIComponent(roomId)}/state/m.room.name`, {\n    headers: { Authorization: `Bearer ${token}` },\n  });\n  const name = resp.res.ok ? (resp.body?.name || '') : '';\n  cache[roomId] = { ...(cache[roomId] || {}), name };\n  return name;\n}\n\nfunction roomTagsFromJoin(roomData) {\n  const events = roomData?.account_data?.events || [];\n  const tagEv = events.find((e) => e?.type === 'm.tag');\n  return Object.keys(tagEv?.content?.tags || {});\n}\n\nlet token = cfg.accessToken;\nif (!token || token.startsWith('REPLACE_')) {\n  const login = await jfetch(`${cfg.matrixBaseUrl}/_matrix/client/v3/login`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      type: 'm.login.password',\n      identifier: { type: 'm.id.user', user: cfg.user },\n      password: cfg.password,\n    }),\n  });\n  if (!login.res.ok || !login.body.access_token) {\n    throw new Error(`Matrix login failed: ${JSON.stringify(login.body)}`);\n  }\n  token = login.body.access_token;\n}\n\nconst whoami = await jfetch(`${cfg.matrixBaseUrl}/_matrix/client/v3/account/whoami`, {\n  headers: { Authorization: `Bearer ${token}` },\n});\nif (!whoami.res.ok || !whoami.body?.user_id) {\n  throw new Error(`Matrix whoami failed: ${JSON.stringify(whoami.body)}`);\n}\nconst ownUserId = whoami.body.user_id;\n\nconst syncUrl = `${cfg.matrixBaseUrl}/_matrix/client/v3/sync?timeout=${encodeURIComponent(String(cfg.pollTimeoutMs))}`;\nconst sync = await jfetch(syncUrl, {\n  headers: { Authorization: `Bearer ${token}` },\n});\nif (!sync.res.ok) {\n  throw new Error(`Matrix sync failed: ${JSON.stringify(sync.body)}`);\n}\n\nconst joined = sync.body.rooms?.join || {};\nconst roomIds = Object.keys(joined);\nconst roomMeta = {};\nconst allowedSet = new Set((cfg.allowedRoomIds || []).filter(Boolean));\nconst wantedNames = (cfg.roomNameIncludes || []).map((s) => String(s).toLowerCase()).filter(Boolean);\nconst requiredTags = new Set((cfg.requiredTags || []).filter(Boolean));\n\nconst replies = [];\nlet checkedEvents = 0;\nconst consideredRooms = [];\n\nfor (const [roomId, roomData] of Object.entries(joined)) {\n  if (allowedSet.size && !allowedSet.has(roomId)) continue;\n\n  const tags = roomTagsFromJoin(roomData);\n  if (requiredTags.size && !tags.some((t) => requiredTags.has(t))) continue;\n\n  let roomName = '';\n  if (wantedNames.length) {\n    roomName = await getRoomName(cfg.matrixBaseUrl, token, roomId, roomMeta);\n    const lower = String(roomName || '').toLowerCase();\n    if (!wantedNames.some((needle) => lower.includes(needle))) continue;\n  }\n\n  consideredRooms.push({ roomId, roomName, tags });\n  const events = roomData?.timeline?.events || [];\n  checkedEvents += events.length;\n\n  const alreadyReplied = new Set(\n    events\n      .filter((ev) => ev?.type === 'm.room.message' && ev?.sender === ownUserId && ev?.content?.body === cfg.replyText)\n      .map((ev) => ev?.content?.['m.relates_to']?.['m.in_reply_to']?.event_id)\n      .filter(Boolean)\n  );\n\n  const pendingPings = events.filter((ev) => {\n    if (ev?.type !== 'm.room.message') return false;\n    if (ev?.sender === ownUserId) return false;\n    if (cfg.allowedSenders.length && !cfg.allowedSenders.includes(ev?.sender || '')) return false;\n    if (ev?.content?.body !== cfg.command) return false;\n    if (alreadyReplied.has(ev.event_id)) return false;\n    return true;\n  });\n\n  const ev = pendingPings.length ? pendingPings[pendingPings.length - 1] : null;\n  if (!ev) continue;\n\n  const txnId = `${Date.now()}-${Math.floor(Math.random() * 100000)}-${replies.length}`;\n  const send = await jfetch(`${cfg.matrixBaseUrl}/_matrix/client/v3/rooms/${encodeURIComponent(roomId)}/send/m.room.message/${txnId}`, {\n    method: 'PUT',\n    headers: {\n      Authorization: `Bearer ${token}`,\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      msgtype: 'm.text',\n      body: cfg.replyText,\n      'm.relates_to': { 'm.in_reply_to': { event_id: ev.event_id } },\n    }),\n  });\n\n  if (!send.res.ok) {\n    throw new Error(`Matrix send failed in ${roomId}: ${JSON.stringify(send.body)}`);\n  }\n\n  replies.push({ roomId, roomName, triggerEventId: ev.event_id, sendResponse: send.body });\n}\n\nif (!replies.length) {\n  return [{ json: {\n    status: 'no_ping',\n    roomCount: roomIds.length,\n    consideredRooms,\n    checkedEvents,\n    filteredRoomCount: consideredRooms.length,\n  } }];\n}\n\nreturn [{ json: {\n  status: 'sent',\n  repliesSent: replies.length,\n  replies,\n  roomCount: roomIds.length,\n  consideredRooms,\n  checkedEvents,\n  note: 'Pollt Matrix-Raeume und antwortet auf neue !ping mit !pong.',\n} }];"
      },
      "id": "matrix-exo-ping-pong",
      "name": "Poll Room and Reply",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        500,
        300
      ]
    }
  ],
  "connections": {
    "Poll Trigger": {
      "main": [
        [
          {
            "node": "Poll Room and Reply",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "ralf-matrix-exo-ping-pong-v1",
  "meta": {
    "templateCredsSetupCompleted": false
  },
  "pinData": {},
  "id": "6f8f25ae-6d89-4a5f-bf8f-4d55f6200002"
}
