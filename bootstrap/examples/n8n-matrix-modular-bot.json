{
  "updatedAt": "2026-02-27T00:00:00.000Z",
  "createdAt": "2026-02-27T00:00:00.000Z",
  "id": "6f8f25ae-6d89-4a5f-bf8f-4d55f6200010",
  "name": "RALF Matrix Modular Bot (Ingest+Router+Responder)",
  "active": false,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "seconds",
              "secondsInterval": 10
            }
          ]
        }
      },
      "id": "sched",
      "name": "Poll Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        220,
        260
      ]
    },
    {
      "parameters": {
        "jsCode": "const cfg = {\n  matrixBaseUrl: 'http://10.10.110.10:8008',\n  user: 'ralf',\n  password: 'REPLACE_WITH_RALF_PASSWORD',\n  accessToken: 'REPLACE_WITH_RALF_ACCESS_TOKEN',\n  maxEventAgeMs: 120000,\n  allowedRoomIds: [],\n};\n\nasync function jfetch(url, options = {}) {\n  const method = options.method || 'GET';\n  const headers = options.headers || {};\n  const body = options.body;\n  try {\n    const resp = await this.helpers.httpRequest({\n      method,\n      url,\n      headers,\n      body,\n      json: true,\n      returnFullResponse: true,\n      ignoreHttpStatusErrors: true,\n    });\n    const statusCode = Number(resp?.statusCode || 0);\n    return { res: { ok: statusCode >= 200 && statusCode < 300, status: statusCode }, body: resp?.body || {} };\n  } catch (err) {\n    const statusCode = Number(err?.statusCode || 0);\n    return { res: { ok: false, status: statusCode }, body: err?.response?.body || { error: String(err?.message || err) } };\n  }\n}\n\nlet token = cfg.accessToken;\nif (!token || token.startsWith('REPLACE_')) {\n  const login = await jfetch(`${cfg.matrixBaseUrl}/_matrix/client/v3/login`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      type: 'm.login.password',\n      identifier: { type: 'm.id.user', user: cfg.user },\n      password: cfg.password,\n    }),\n  });\n  if (!login.res.ok || !login.body.access_token) throw new Error(`Matrix login failed: ${JSON.stringify(login.body)}`);\n  token = login.body.access_token;\n}\n\nconst whoami = await jfetch(`${cfg.matrixBaseUrl}/_matrix/client/v3/account/whoami`, {\n  headers: { Authorization: `Bearer ${token}` },\n});\nif (!whoami.res.ok || !whoami.body?.user_id) throw new Error(`Matrix whoami failed: ${JSON.stringify(whoami.body)}`);\nconst ownUserId = whoami.body.user_id;\n\nconst joinedResp = await jfetch(`${cfg.matrixBaseUrl}/_matrix/client/v3/joined_rooms`, {\n  headers: { Authorization: `Bearer ${token}` },\n});\nif (!joinedResp.res.ok) throw new Error(`Matrix joined_rooms failed: ${JSON.stringify(joinedResp.body)}`);\n\nconst staticData = $getWorkflowStaticData('global');\nstaticData.seen = staticData.seen || {};\nconst nowMs = Date.now();\n\nfor (const k of Object.keys(staticData.seen)) {\n  if ((nowMs - Number(staticData.seen[k] || 0)) > 3600000) delete staticData.seen[k];\n}\n\nconst allowedSet = new Set((cfg.allowedRoomIds || []).filter(Boolean));\nconst out = [];\nfor (const roomId of (joinedResp.body.joined_rooms || [])) {\n  if (allowedSet.size && !allowedSet.has(roomId)) continue;\n\n  const msgResp = await jfetch(`${cfg.matrixBaseUrl}/_matrix/client/v3/rooms/${encodeURIComponent(roomId)}/messages?dir=b&limit=30`, {\n    headers: { Authorization: `Bearer ${token}` },\n  });\n  if (!msgResp.res.ok) continue;\n\n  const events = (msgResp.body?.chunk || []).filter((ev) => ev?.type === 'm.room.message');\n  for (const ev of events) {\n    const body = String(ev?.content?.body || '').trim();\n    if (!body.startsWith('!')) continue;\n    if (ev?.sender === ownUserId) continue;\n    const eventTs = Number(ev?.origin_server_ts || 0);\n    if (!eventTs || (nowMs - eventTs) > Number(cfg.maxEventAgeMs || 120000)) continue;\n    if (staticData.seen[ev.event_id]) continue;\n\n    staticData.seen[ev.event_id] = nowMs;\n    out.push({\n      json: {\n        matrixBaseUrl: cfg.matrixBaseUrl,\n        token,\n        ownUserId,\n        roomId,\n        eventId: ev.event_id,\n        sender: ev.sender,\n        body,\n        eventTs,\n      }\n    });\n  }\n}\n\nreturn out;"
      },
      "id": "ingest",
      "name": "Ingest Commands",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        520,
        260
      ]
    },
    {
      "parameters": {
        "jsCode": "const body = String($json.body || '').trim();\nconst lower = body.toLowerCase();\nlet intent = 'ignore';\nlet payload = '';\n\nif (lower === '!ping') {\n  intent = 'ping';\n} else if (lower.startsWith('!ralf')) {\n  intent = 'qa';\n  payload = body.slice('!ralf'.length).trim();\n} else if (lower.startsWith('!plan')) {\n  intent = 'plan';\n  payload = body.slice('!plan'.length).trim();\n}\n\nreturn [{ json: { ...$json, intent, payload } }];"
      },
      "id": "router",
      "name": "Intent Router",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        780,
        260
      ]
    },
    {
      "parameters": {
        "jsCode": "async function jfetch(url, options = {}) {\n  const method = options.method || 'GET';\n  const headers = options.headers || {};\n  const body = options.body;\n  const resp = await this.helpers.httpRequest({\n    method,\n    url,\n    headers,\n    body,\n    json: true,\n    returnFullResponse: true,\n    ignoreHttpStatusErrors: true,\n  });\n  const statusCode = Number(resp?.statusCode || 0);\n  return { ok: statusCode >= 200 && statusCode < 300, status: statusCode, body: resp?.body || {} };\n}\n\nconst { intent, payload, matrixBaseUrl, token, roomId, eventId } = $json;\nif (!['ping','qa','plan'].includes(intent)) return [{ json: { ...$json, status: 'ignored' } }];\n\nlet reply = '';\nif (intent === 'ping') {\n  reply = '!pong';\n} else if (intent === 'qa') {\n  if (!payload) reply = 'Nutze: !ralf <frage>';\n  else if (payload.toLowerCase().includes('status')) reply = 'RALF Status: Basisdienste laufen. N8N modular aktiv.';\n  else reply = 'Verstanden. Ich antworte aktuell regelbasiert.';\n} else if (intent === 'plan') {\n  const target = payload || '(leer)';\n  reply = `Plan fuer: ${target}\\n1) Scope klaeren\\n2) Abhaengigkeiten pr\u00fcfen\\n3) Ausfuehrung in Phasen`;\n}\n\nconst txnId = `${Date.now()}-${Math.floor(Math.random() * 100000)}`;\nconst send = await jfetch(`${matrixBaseUrl}/_matrix/client/v3/rooms/${encodeURIComponent(roomId)}/send/m.room.message/${txnId}`, {\n  method: 'PUT',\n  headers: {\n    Authorization: `Bearer ${token}`,\n    'Content-Type': 'application/json',\n  },\n  body: JSON.stringify({\n    msgtype: 'm.text',\n    body: reply,\n    'm.relates_to': { 'm.in_reply_to': { event_id: eventId } },\n  }),\n});\n\nif (!send.ok) throw new Error(`Matrix send failed: ${JSON.stringify(send.body)}`);\nreturn [{ json: { ...$json, status: 'sent', reply } }];"
      },
      "id": "responder",
      "name": "Responder",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1040,
        260
      ]
    }
  ],
  "connections": {
    "Poll Trigger": {
      "main": [
        [
          {
            "node": "Ingest Commands",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ingest Commands": {
      "main": [
        [
          {
            "node": "Intent Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Intent Router": {
      "main": [
        [
          {
            "node": "Responder",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "pinData": {},
  "versionId": "00000000-0000-4000-8000-000000000010",
  "triggerCount": 1,
  "tags": []
}
