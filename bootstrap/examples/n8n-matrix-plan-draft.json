{
  "name": "RALF Matrix Plan Draft (Gatekeeper Poll)",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "seconds",
              "secondsInterval": 20
            }
          ]
        }
      },
      "id": "plan-trigger",
      "name": "Poll Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        240,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "const cfg = {\n  matrixBaseUrl: 'http://10.10.110.10:8008',\n  user: 'ralf',\n  password: 'REPLACE_WITH_RALF_PASSWORD',\n  commandPrefix: '!plan',\n  pollTimeoutMs: 1,\n  allowedRoomIds: [],\n};\n\nasync function jfetch(url, options = {}) {\n  const method = options.method || 'GET';\n  const headers = options.headers || {};\n  const body = options.body;\n\n  try {\n    const resp = await this.helpers.httpRequest({\n      method,\n      url,\n      headers,\n      body,\n      json: true,\n      returnFullResponse: true,\n      ignoreHttpStatusErrors: true,\n    });\n    const statusCode = Number(resp?.statusCode || 0);\n    return {\n      res: { ok: statusCode >= 200 && statusCode < 300, status: statusCode },\n      body: resp?.body || {},\n    };\n  } catch (err) {\n    const statusCode = Number(err?.statusCode || 0);\n    return {\n      res: { ok: false, status: statusCode },\n      body: err?.response?.body || { error: String(err?.message || err || 'http request failed') },\n    };\n  }\n}\n\nfunction gate(target) {\n  const t = target.toLowerCase();\n  if (t.includes('docker')) return { level: 'BLOCKER', reason: 'Docker ist laut Betriebsregeln ausgeschlossen (LXC-first).' };\n  if (t.includes('public') || t.includes('extern')) return { level: 'WARN', reason: 'Externe Freigabe braucht zusaetzliche Sicherheitspruefung.' };\n  if (t.length < 5) return { level: 'WARN', reason: 'Ziel ist zu unspezifisch.' };\n  return { level: 'OK', reason: 'Keine harte Regelverletzung erkannt.' };\n}\n\nfunction draft(target, g) {\n  return [\n    `Plan fuer: ${target}`,\n    `Gate: ${g.level} - ${g.reason}`,\n    '',\n    '1) Scope und Abhaengigkeiten klaeren',\n    '2) Ressourcen pruefen (CPU/RAM/Disk/Netz)',\n    '3) Stack-Reihenfolge festlegen (Infra -> Config -> Smoke)',\n    '4) Artefakte erzeugen (Tofu/Ansible/n8n)',\n    '5) Freigabe einholen',\n    '6) Ausfuehren und Smoke pruefen'\n  ].join('\\n');\n}\n\nconst staticData = $getWorkflowStaticData('global');\nconst login = await jfetch(`${cfg.matrixBaseUrl}/_matrix/client/v3/login`, {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({\n    type: 'm.login.password',\n    identifier: { type: 'm.id.user', user: cfg.user },\n    password: cfg.password,\n  }),\n});\nif (!login.res.ok || !login.body.access_token) throw new Error(`Matrix login failed: ${JSON.stringify(login.body)}`);\n\nconst token = login.body.access_token;\nconst ownUserId = login.body.user_id || `@${cfg.user}:otta.zone`;\n\nlet syncUrl = `${cfg.matrixBaseUrl}/_matrix/client/v3/sync?timeout=${encodeURIComponent(String(cfg.pollTimeoutMs))}`;\nif (staticData.nextBatch) {\n  syncUrl += `&since=${encodeURIComponent(String(staticData.nextBatch))}`;\n}\nconst sync = await jfetch(syncUrl, {\n  headers: { Authorization: `Bearer ${token}` },\n});\nif (!sync.res.ok) throw new Error(`Matrix sync failed: ${JSON.stringify(sync.body)}`);\n\nconst nextBatch = sync.body.next_batch;\nconst joined = sync.body.rooms?.join || {};\nif (!staticData.initialized) {\n  staticData.initialized = true;\n  if (nextBatch) staticData.nextBatch = nextBatch;\n  return [{ json: { status: 'initialized', roomCount: Object.keys(joined).length } }];\n}\n\nconst allowedSet = new Set((cfg.allowedRoomIds || []).filter(Boolean));\nconst replies = [];\nfor (const [roomId, roomData] of Object.entries(joined)) {\n  if (allowedSet.size && !allowedSet.has(roomId)) continue;\n  const events = roomData?.timeline?.events || [];\n  for (const ev of events) {\n    const body = ev?.content?.body || '';\n    if (ev?.type !== 'm.room.message') continue;\n    if (!body.startsWith(cfg.commandPrefix)) continue;\n    if (ev?.sender === ownUserId) continue;\n\n    const target = body.slice(cfg.commandPrefix.length).trim();\n    const g = gate(target);\n    const reply = draft(target || '(leer)', g);\n    const txnId = `${Date.now()}-${Math.floor(Math.random() * 100000)}-${replies.length}`;\n\n    const send = await jfetch(`${cfg.matrixBaseUrl}/_matrix/client/v3/rooms/${encodeURIComponent(roomId)}/send/m.room.message/${txnId}`, {\n      method: 'PUT',\n      headers: {\n        Authorization: `Bearer ${token}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        msgtype: 'm.text',\n        body: reply,\n        'm.relates_to': { 'm.in_reply_to': { event_id: ev.event_id } }\n      }),\n    });\n    if (!send.res.ok) throw new Error(`Matrix send failed in ${roomId}: ${JSON.stringify(send.body)}`);\n    replies.push({ roomId, triggerEventId: ev.event_id, gate: g.level });\n  }\n}\n\nif (nextBatch) staticData.nextBatch = nextBatch;\nif (!replies.length) return [{ json: { status: 'no_plan_request' } }];\nreturn [{ json: { status: 'sent', repliesSent: replies.length, replies } }];"
      },
      "id": "plan-code",
      "name": "Poll Plan Requests and Reply",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        500,
        300
      ]
    }
  ],
  "connections": {
    "Poll Trigger": {
      "main": [
        [
          {
            "node": "Poll Plan Requests and Reply",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "ralf-matrix-plan-draft-v1",
  "meta": {
    "templateCredsSetupCompleted": false
  },
  "pinData": {},
  "id": "6f8f25ae-6d89-4a5f-bf8f-4d55f6200004"
}
